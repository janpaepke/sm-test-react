/*!
 * ScrollMagic v3.0.0-alpha
 * Author: Jan Paepke (https://janpaepke.de)
 * Contributors: Stefan Knop
 * Generated: 2021-05-25
 * License: (MIT OR GPL-3.0+)
 * Docs & Demos: https://scrollmagic.io
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).ScrollMagic=t()}(this,(function(){"use strict";const e=e=>"number"==typeof e,t=e=>"string"==typeof e,s=e=>void 0===e,i=e=>null===e,n=e=>e instanceof Window,r=e=>e instanceof HTMLElement,o=e=>e instanceof SVGElement;class c{constructor(){this.callbacks=new Map}addEventListener(e,t){let i=this.callbacks.get(e);return s(i)&&(i=[],this.callbacks.set(e,i)),i.push(t),()=>this.removeEventListener(e,t)}removeEventListener(e,t){const i=this.callbacks.get(e);if(s(i))return;const n=i.filter((e=>e!==t));this.callbacks.set(e,n)}dispatchEvent(e){const t=this.callbacks.get(e.type);s(t)||t.forEach((t=>t(e)))}}const l=(e,t)=>{let s=0;const i=function(...i){clearTimeout(s),s=window.setTimeout((()=>{s=0,e.apply(this,i)}),t)};return i.cancel=function(){clearTimeout(s),s=0},i},a=e=>{const t=n(e)?document.documentElement:e,{clientWidth:s,scrollHeight:i,scrollWidth:r}=t;let{clientHeight:o}=t;if(n(e)){const{innerHeight:t}=e;t-15>o&&(o=t)}return{clientWidth:s,clientHeight:o,scrollHeight:i,scrollWidth:r}},h=e=>n(e)?window.pageYOffset:e.scrollTop,d=e=>n(e)?window.pageXOffset:e.scrollLeft,u=e=>({left:d(e),top:h(e)}),g=(e,t,s,i)=>(e.addEventListener(t,s,i),e.removeEventListener.bind(e,t,s,i)),p=e=>{let t=0;const s=function(...s){0===t&&(t=requestAnimationFrame((()=>{t=0,e.apply(this,s)})))};return s.cancel=()=>{cancelAnimationFrame(t),t=0},s};var b;!function(e){e.Scroll="scroll",e.Resize="resize"}(b||(b={}));class v{constructor(e,t,s={deltaX:0,deltaY:0}){this.target=e,this.type=t,this.scrollDelta=s}}class f{constructor(e){this.scrollParent=e,this.dimensions={clientWidth:0,clientHeight:0,scrollWidth:0,scrollHeight:0},this.scrollPos={top:0,left:0},this.positionCache={top:0,left:0},this.dispatcher=new c,this.cleanups=[];const t=p(this.updateScrollPos.bind(this)),s=l(this.updateDimensions.bind(this),100);if(!n(e)){const e=p(this.updatePosition.bind(this));this.cleanups.push(e.cancel,this.subscribeMove(e))}this.cleanups.push(t.cancel,s.cancel,this.subscribeScroll(t),this.subscribeResize(s)),this.updateScrollPos(),this.updateDimensions()}updateScrollPos(){const e=this.scrollPos;this.scrollPos=u(this.scrollParent);const t=this.scrollPos.top-e.top,s=this.scrollPos.left-e.left;this.dispatcher.dispatchEvent(new v(this,b.Scroll,{deltaX:s,deltaY:t}))}updateDimensions(){this.dimensions=a(this.scrollParent),this.dispatcher.dispatchEvent(new v(this,b.Resize))}updatePosition(){const{top:e,left:t}=this.scrollParent.getBoundingClientRect();this.positionCache={top:e,left:t}}subscribeResize(e){const{scrollParent:t}=this;if(n(t))return g(t,b.Resize,e);const s=new ResizeObserver(e);return s.observe(t),()=>s.unobserve(t)}subscribeScroll(e){return g(this.scrollParent,b.Scroll,e)}subscribeMove(e){const t=[g(window,b.Scroll,e),g(window,b.Resize,e)];return()=>t.forEach((e=>e()))}subscribe(e,t){return this.dispatcher.addEventListener(e,t)}get size(){return this.dimensions}get position(){return this.positionCache}destroy(){this.cleanups.forEach((e=>e())),this.cleanups=[]}}const m="ScrollMagic";class E extends Error{constructor(e){super(e),this.name=m+"Error"}}class S extends E{constructor(e){super("Internal Error: "+e)}}const P=e=>new E(e),w=e=>new S(e),O=(e,...t)=>{null==console||console.warn(`${m} Warning: ${e}`,...t)};class z{constructor(e){this.scene=e,this.unsubscribers=[]}attach(e,t){s(this.container)||this.detach();let i=z.cache.get(e);s(i)&&(i=[new f(e),new Set],z.cache.set(e,i));const[n,r]=i;r.add(this.scene),this.container=n,this.unsubscribers=[n.subscribe("resize",t),n.subscribe("scroll",t)]}detach(){if(s(this.container))return;const{scrollParent:e}=this.container,t=z.cache.get(e);if(s(t))throw w("No cache info for scrollParent");const[i,n]=t;n.delete(this.scene),this.unsubscribers.forEach((e=>e())),this.unsubscribers=[],0===n.size&&(i.destroy(),z.cache.delete(e)),this.container=void 0}get rect(){if(s(this.container))throw w("Can't get size when not attached to a container");return Object.assign(Object.assign({},this.container.position),this.container.size)}}z.cache=new Map;class C{constructor(e,t){this.execute=e,this.onSchedule=t,this.conditions=[]}schedule(e){s(e)&&(this.conditions=[],e=()=>!0),this.conditions.push(e),this.onSchedule()}resetConditions(){this.conditions=[]}get conditionsMet(){return this.conditions.some((e=>e()))}}class y{constructor(e){this.executeThrottled=p(this.execute.bind(this)),this.commands=Object.entries(e).reduce(((e,[t,s])=>Object.assign(Object.assign({},e),{[t]:new C(s,this.executeThrottled)})),{})}execute(){Object.values(this.commands).forEach((e=>{e.conditionsMet&&e.execute(),e.resetConditions()}))}cancel(){this.executeThrottled.cancel()}}const j={element:null,scrollParent:window,vertical:!0,triggerStart:null,triggerEnd:null,elementStart:0,elementEnd:0},B={default:e=>e,fallback:()=>0},k={start:"top",end:"bottom",size:"height",clientSize:"clientHeight",scrollSize:"scrollHeight",scrollDelta:"deltaY"},M={start:"left",end:"right",size:"width",clientSize:"clientWidth",scrollSize:"scrollWidth",scrollDelta:"deltaX"},x=e=>e?k:M,L=(e,t)=>Object.entries(x(e)).reduce(((e,[s,i])=>Object.assign(Object.assign({},e),{[s]:t[i]})),{}),R=(e,t,s=((e,t,s)=>`Invalid value ${e} for ${t}. ${s}`))=>Object.keys(e).reduce(((i,n)=>{var r;const o=n,c=e[o],l=t[o];let a;try{a=null!==(r=null==l?void 0:l(c))&&void 0!==r?r:c}catch(e){throw P(s(c,o,e.message))}return i[o]=a,i}),{}),T="center",I=e=>100*e+"%",D=([e,t])=>"px"===t?()=>e:t=>e/100*t,H=s=>{if(e(s))return()=>s;if(t(s)){if(T===s){return D([50,"%"])}return(e=>{const t=e.match(/^([+-])?(\d+|\d*[.]\d+)(%|px)$/);if(i(t))throw P("String value must be number with unit, i.e. 20px or 80% or 'center' (=50%)");const[,s,n,r]=t;return D([parseFloat(`${null!=s?s:""}${n}`),r])})(s)}let n;try{n=e(s(1))}catch(e){throw P("Unsupported value type")}if(!n)throw P("Function must return a number");return s},W=e=>{const s=t(e)?(e=>{const t=document.querySelector(e);if(i(t))throw P("No element found for selector "+e);return t})(e):e,{body:n}=window.document;if(!r(s)&&!o(s)||!n.contains(s))throw P("Invalid element supplied");return s},F=e=>t=>i(t)?t:e(t),$=(e,t)=>i(e)||s(e)?t():e,V={element:F(W),scrollParent:e=>{if(n(e)||e instanceof Document)return window;const t=W(e);if(o(t))throw P("Can't use SVG as scrollParent");return t},vertical:e=>!!e,triggerStart:F(H),triggerEnd:F(H),elementStart:H,elementEnd:H},U=e=>((e,t,s=(e=>{O(`Unknown property ${e} will be disregarded`)}))=>Object.entries(e).reduce(((e,[i,n])=>i in t==0?(null==s||s(i),e):(e[i]=n,e)),{}))(e,j),X=(e,t)=>{const s=U(e),c=R(s,V);const l=(e=>{const{scrollParent:t,element:s}=e,c=e=>$(e,(()=>i(s)?B.fallback:B.default));return R(e,{element:e=>$(e,(()=>{const e=n(t)?document.body:t.firstElementChild;if(i(e)||!r(e)&&!o(e))throw P("Could not autodetect element, as scrollParent has no valid children.");return e})),triggerStart:c,triggerEnd:c})})(Object.assign(Object.assign({},t),c));return(e=>{const{triggerStart:t,triggerEnd:s,elementStart:i,elementEnd:n,vertical:r,scrollParent:o}=e,{size:c}=Y(e),{clientSize:l}=L(r,a(o));c-i(c)-n(c)-(l-t(l)-s(l))<0&&O("Detected no overlap with the configured track options. This means ScrollMagic will not trigger unless this changes later on (i.e. due to resizes).",Object.assign(Object.assign({},e),{triggerStart:t(c),triggerEnd:s(c),elementStart:i(c),elementEnd:n(c)}))})(l),{sanitized:s,processed:l}},Y=({vertical:e,element:t})=>L(e,t.getBoundingClientRect());var A,Q,q;!function(e){e.Enter="enter",e.Leave="leave",e.Progress="progress"}(A||(A={})),function(e){e.Start="start",e.Inside="inside",e.End="end"}(Q||(Q={})),function(e){e.Forward="forward",e.Reverse="reverse"}(q||(q={}));class G{constructor(e,t,s){this.target=e,this.type=t,this.location=A.Progress===t?Q.Inside:A.Enter===t&&s||A.Leave===t&&!s?Q.Start:Q.End,this.direction=s?q.Forward:q.Reverse}}const N=(e,[t,s])=>Object.assign(Object.assign({},e),{[t]:s}),J=(e,t)=>Object.entries(e).filter((([e,s])=>s!==t[e])).reduce(N,{}),K=(e,t)=>parseFloat(e.toFixed(t)),Z=({top:e,right:t,bottom:s,left:i})=>[e,t,s,i].join(" "),_="0px";class ee{constructor(e,t){this.callback=e,this.options={root:null,margin:{top:_,right:_,bottom:_,left:_}},this.observedElements=new Map,s(t)||(this.options=Object.assign(Object.assign({},this.options),t))}observerCallback(e,t){e.forEach((({target:e,isIntersecting:i})=>{var n;let[r,o]=null!==(n=this.observedElements.get(e))&&void 0!==n?n:[];const c=r&&o;t===this.observerEnter?r=i:o=i,this.observedElements.set(e,[r,o]);const l=r&&o;s(l)||c===l||this.callback(l,e)}))}createObserver(e){const t=this.options.root,s=new IntersectionObserver(this.observerCallback.bind(this),{root:t,rootMargin:e});return[...this.observedElements.keys()].forEach((e=>s.observe(e))),s}rebuildObserver(){var e,t;null===(e=this.observerEnter)||void 0===e||e.disconnect(),null===(t=this.observerLeave)||void 0===t||t.disconnect();const{margin:s}=this.options,i=e=>Math.max(0,parseFloat(e))+"%",n=Object.assign(Object.assign({},s),{top:i(s.top)}),r=Object.assign(Object.assign({},s),{bottom:i(s.bottom)});this.observerEnter=this.createObserver(Z(n)),this.observerLeave=this.createObserver(Z(r))}optionsChanged({root:e,margin:t}){return!s(e)&&e!==this.options.root||!s(t)&&Object.keys(J(t,this.options.margin)).length>0}modify(e){return this.optionsChanged(e)?(this.options=Object.assign(Object.assign({},this.options),e),this.rebuildObserver(),this):this}observe(e){var t,s;return this.observedElements.has(e)||(this.observedElements.set(e,[void 0,void 0]),null===(t=this.observerEnter)||void 0===t||t.observe(e),null===(s=this.observerLeave)||void 0===s||s.observe(e)),this}unobserve(e){var t,s;return this.observedElements.delete(e)&&(null===(t=this.observerEnter)||void 0===t||t.unobserve(e),null===(s=this.observerLeave)||void 0===s||s.unobserve(e)),this}disconnect(){var e,t;this.observedElements.clear(),null===(e=this.observerEnter)||void 0===e||e.disconnect(),null===(t=this.observerLeave)||void 0===t||t.disconnect()}}class te{constructor(e={}){this.name="ScrollMagic",this.dispatcher=new c,this.container=new z(this),this.resizeObserver=new ResizeObserver(p(this.onElementResize.bind(this))),this.viewportObserver=new ee(this.onIntersectionChange.bind(this)),this.executionQueue=new y({elementBounds:this.updateElementBoundsCache.bind(this),containerBounds:this.updateContainerBoundsCache.bind(this),viewportObserver:this.updateViewportObserver.bind(this),progress:this.updateProgress.bind(this)}),this.update=this.executionQueue.commands,this.plugins=new Set,this.elementBoundsCache={start:0,size:0,offsetStart:0,offsetEnd:0,trackSize:0},this.containerBoundsCache={clientSize:0,offsetStart:0,offsetEnd:0,trackSize:0,scrollSize:0},this.currentProgress=0;const t=Object.assign(Object.assign({},te.defaultOptionsPublic),e);this.modify(t)}getViewportMargin(){const{vertical:e}=this.optionsPrivate,{start:t,end:s}=x(e),{start:i,end:n}=x(!e),{scrollSize:r,clientSize:o}=L(!e,this.container.rect),{clientSize:c,offsetStart:l,offsetEnd:a}=this.containerBoundsCache,{offsetStart:h,offsetEnd:d}=this.elementBoundsCache,u=c-a+d,g=c<=0,p=g?0:-K((c-l+h)/c,5),b=g?0:-K(u/c,5),v=o<=0?0:I((r-o)/o);return{[s]:I(p),[t]:I(b),[i]:v,[n]:v}}getTrackSize(){return this.elementBoundsCache.trackSize+this.containerBoundsCache.trackSize}updateIntersectingState(e){this.intersecting=e}updateElementBoundsCache(){const{elementStart:e,elementEnd:t,element:s,vertical:i}=this.optionsPrivate,{start:n,size:r}=L(i,s.getBoundingClientRect()),o=e(r),c=t(r);this.elementBoundsCache={start:n,size:r,offsetStart:o,offsetEnd:c,trackSize:r-o-c}}updateContainerBoundsCache(){const{triggerStart:e,triggerEnd:t,vertical:s}=this.optionsPrivate,{clientSize:i,scrollSize:n}=L(s,this.container.rect),r=e(i),o=t(i);this.containerBoundsCache={clientSize:i,scrollSize:n,offsetStart:r,offsetEnd:o,trackSize:-(i-r-o)}}updateProgress(){const{offsetStart:e,start:t}=this.elementBoundsCache,{offsetStart:s}=this.containerBoundsCache,{start:i}=L(this.optionsPrivate.vertical,this.container.rect),n=i+s-(t+e),r=this.getTrackSize();if(r<0)return;const o=this.currentProgress,c=Math.min(Math.max(n/r,0),1),l=c-o;if(0===l)return;this.currentProgress=c;const a=l>0;0!==o&&1!==o||this.triggerEvent(A.Enter,a),this.triggerEvent(A.Progress,a),0!==c&&1!==c||this.triggerEvent(A.Leave,a)}updateViewportObserver(){const{scrollParent:e}=this.optionsPrivate,t={margin:this.getViewportMargin(),root:n(e)?null:e};this.viewportObserver.modify(t)}onOptionChanges(e){const t=Object.keys(e);if(0===t.length)return;const s=t.includes.bind(t),i=s("elementStart"),n=s("elementEnd"),r=s("element"),o=s("scrollParent"),c=s("triggerStart"),l=s("triggerEnd"),a=s("vertical");if((i||n||r)&&(this.update.elementBounds.schedule(),r)){this.updateIntersectingState(void 0);const{element:e}=this.optionsPrivate;this.viewportObserver.disconnect(),this.viewportObserver.observe(e),this.resizeObserver.disconnect(),this.resizeObserver.observe(e)}(o||c||l||a)&&(this.update.viewportObserver.schedule(),o&&(this.update.containerBounds.schedule(),this.updateIntersectingState(void 0),this.container.attach(this.optionsPrivate.scrollParent,this.onContainerUpdate.bind(this)))),this.update.progress.schedule()}onElementResize(){const{update:e,elementBoundsCache:t}=this,{offsetStart:s,offsetEnd:i}=t,n=()=>s!==t.offsetStart||i!==t.offsetEnd;e.elementBounds.schedule(),e.viewportObserver.schedule(n),this.intersecting&&e.progress.schedule(n)}onContainerUpdate(e){const{update:t}=this;if("resize"===e.type){this.update.containerBounds.schedule(),this.intersecting&&t.elementBounds.schedule(),t.viewportObserver.schedule();const{start:e}=this.elementBoundsCache,s=()=>e!==this.elementBoundsCache.start;return void t.progress.schedule(s)}const{scrollDelta:s}=L(this.optionsPrivate.vertical,e.scrollDelta);if(0===s)return;const i=Math.abs(s)>this.getTrackSize();(this.intersecting||i)&&(t.elementBounds.schedule(),t.progress.schedule())}onIntersectionChange(e,t){t===this.optionsPrivate.element&&(this.updateIntersectingState(e),this.update.progress.schedule())}triggerEvent(e,t){this.dispatcher.dispatchEvent(new G(this,e,t))}modify(e){const{sanitized:t,processed:i}=X(e,this.optionsPrivate),n=s(this.optionsPublic)?t:J(t,this.optionsPublic);return this.optionsPublic=Object.assign(Object.assign({},this.optionsPublic),n),this.optionsPrivate=i,this.onOptionChanges(n),this.plugins.forEach((e=>{var t;return null===(t=e.onModify)||void 0===t?void 0:t.call(this,n)})),this}addPlugin(e){var t;return this.plugins.add(e),null===(t=e.onAdd)||void 0===t||t.call(this),this}removePlugin(e){var t;return this.plugins.delete(e),null===(t=e.onRemove)||void 0===t||t.call(this),this}set element(e){this.modify({element:e})}get element(){return this.optionsPublic.element}set scrollParent(e){this.modify({scrollParent:e})}get scrollParent(){return this.optionsPublic.scrollParent}set vertical(e){this.modify({vertical:e})}get vertical(){return this.optionsPublic.vertical}set triggerStart(e){this.modify({triggerStart:e})}get triggerStart(){return this.optionsPublic.triggerStart}set triggerEnd(e){this.modify({triggerEnd:e})}get triggerEnd(){return this.optionsPublic.triggerEnd}set elementStart(e){this.modify({elementStart:e})}get elementStart(){return this.optionsPublic.elementStart}set elementEnd(e){this.modify({elementEnd:e})}get elementEnd(){return this.optionsPublic.elementEnd}get progress(){return this.currentProgress}get scrollOffset(){this.updateElementBoundsCache();const{scrollParent:e,vertical:t}=this.optionsPrivate,{start:s,offsetStart:i,trackSize:n}=this.elementBoundsCache,{clientSize:r,offsetStart:o,offsetEnd:c}=this.containerBoundsCache,{start:l}=L(t,u(e)),a=s+l+i,h=a+n;return{start:Math.floor(a-o),end:Math.ceil(h-r+c)}}get computedOptions(){const{offsetStart:e,offsetEnd:t}=this.containerBoundsCache,{offsetStart:s,offsetEnd:i}=this.elementBoundsCache;return Object.assign(Object.assign({},this.optionsPrivate),{triggerStart:e,triggerEnd:t,elementStart:s,elementEnd:i})}get pluginList(){return[...this.plugins]}on(e,t){return this.dispatcher.addEventListener(e,t),this}off(e,t){return this.dispatcher.removeEventListener(e,t),this}subscribe(e,t){return this.dispatcher.addEventListener(e,t)}destroy(){this.executionQueue.cancel(),this.resizeObserver.disconnect(),this.viewportObserver.disconnect(),this.container.detach(),this.plugins.forEach(this.removePlugin.bind(this))}static defaultOptions(e={}){return this.defaultOptionsPublic=Object.assign(Object.assign({},this.defaultOptionsPublic),U(e)),this.defaultOptionsPublic}}return te.defaultOptionsPublic=j,te.EventType=A,te.EventLocation=Q,te.EventScrollDirection=q,te}));
//# sourceMappingURL=scrollmagic.js.map
