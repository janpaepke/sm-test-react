/*!
 * ScrollMagic v3.0.0-alpha
 * Author: Jan Paepke (https://janpaepke.de)
 * Contributors: Stefan Knop
 * Generated: 2021-05-25
 * License: (MIT OR GPL-3.0+)
 * Docs & Demos: https://scrollmagic.io
 */

const t=t=>"number"==typeof t,e=t=>"string"==typeof t,s=t=>void 0===t,i=t=>null===t,n=t=>t instanceof Window,r=t=>t instanceof HTMLElement,o=t=>t instanceof SVGElement;class c{constructor(){this.callbacks=new Map}addEventListener(t,e){let i=this.callbacks.get(t);return s(i)&&(i=[],this.callbacks.set(t,i)),i.push(e),()=>this.removeEventListener(t,e)}removeEventListener(t,e){const i=this.callbacks.get(t);if(s(i))return;const n=i.filter((t=>t!==e));this.callbacks.set(t,n)}dispatchEvent(t){const e=this.callbacks.get(t.type);s(e)||e.forEach((e=>e(t)))}}const a=(t,e)=>{let s=0;const i=function(...i){clearTimeout(s),s=window.setTimeout((()=>{s=0,t.apply(this,i)}),e)};return i.cancel=function(){clearTimeout(s),s=0},i},l=t=>{const e=n(t)?document.documentElement:t,{clientWidth:s,scrollHeight:i,scrollWidth:r}=e;let{clientHeight:o}=e;if(n(t)){const{innerHeight:e}=t;e-15>o&&(o=e)}return{clientWidth:s,clientHeight:o,scrollHeight:i,scrollWidth:r}},h=t=>n(t)?window.pageYOffset:t.scrollTop,d=t=>n(t)?window.pageXOffset:t.scrollLeft,u=t=>({left:d(t),top:h(t)}),g=(t,e,s,i)=>(t.addEventListener(e,s,i),t.removeEventListener.bind(t,e,s,i)),p=t=>{let e=0;const s=function(...s){0===e&&(e=requestAnimationFrame((()=>{e=0,t.apply(this,s)})))};return s.cancel=()=>{cancelAnimationFrame(e),e=0},s};var b;!function(t){t.Scroll="scroll",t.Resize="resize"}(b||(b={}));class v{constructor(t,e,s={deltaX:0,deltaY:0}){this.target=t,this.type=e,this.scrollDelta=s}}class f{constructor(t){this.scrollParent=t,this.dimensions={clientWidth:0,clientHeight:0,scrollWidth:0,scrollHeight:0},this.scrollPos={top:0,left:0},this.positionCache={top:0,left:0},this.dispatcher=new c,this.cleanups=[];const e=p(this.updateScrollPos.bind(this)),s=a(this.updateDimensions.bind(this),100);if(!n(t)){const t=p(this.updatePosition.bind(this));this.cleanups.push(t.cancel,this.subscribeMove(t))}this.cleanups.push(e.cancel,s.cancel,this.subscribeScroll(e),this.subscribeResize(s)),this.updateScrollPos(),this.updateDimensions()}updateScrollPos(){const t=this.scrollPos;this.scrollPos=u(this.scrollParent);const e=this.scrollPos.top-t.top,s=this.scrollPos.left-t.left;this.dispatcher.dispatchEvent(new v(this,b.Scroll,{deltaX:s,deltaY:e}))}updateDimensions(){this.dimensions=l(this.scrollParent),this.dispatcher.dispatchEvent(new v(this,b.Resize))}updatePosition(){const{top:t,left:e}=this.scrollParent.getBoundingClientRect();this.positionCache={top:t,left:e}}subscribeResize(t){const{scrollParent:e}=this;if(n(e))return g(e,b.Resize,t);const s=new ResizeObserver(t);return s.observe(e),()=>s.unobserve(e)}subscribeScroll(t){return g(this.scrollParent,b.Scroll,t)}subscribeMove(t){const e=[g(window,b.Scroll,t),g(window,b.Resize,t)];return()=>e.forEach((t=>t()))}subscribe(t,e){return this.dispatcher.addEventListener(t,e)}get size(){return this.dimensions}get position(){return this.positionCache}destroy(){this.cleanups.forEach((t=>t())),this.cleanups=[]}}const m="ScrollMagic";class E extends Error{constructor(t){super(t),this.name=m+"Error"}}class S extends E{constructor(t){super("Internal Error: "+t)}}const P=t=>new E(t),w=t=>new S(t),O=(t,...e)=>{null==console||console.warn(`${m} Warning: ${t}`,...e)};class z{constructor(t){this.scene=t,this.unsubscribers=[]}attach(t,e){s(this.container)||this.detach();let i=z.cache.get(t);s(i)&&(i=[new f(t),new Set],z.cache.set(t,i));const[n,r]=i;r.add(this.scene),this.container=n,this.unsubscribers=[n.subscribe("resize",e),n.subscribe("scroll",e)]}detach(){if(s(this.container))return;const{scrollParent:t}=this.container,e=z.cache.get(t);if(s(e))throw w("No cache info for scrollParent");const[i,n]=e;n.delete(this.scene),this.unsubscribers.forEach((t=>t())),this.unsubscribers=[],0===n.size&&(i.destroy(),z.cache.delete(t)),this.container=void 0}get rect(){if(s(this.container))throw w("Can't get size when not attached to a container");return Object.assign(Object.assign({},this.container.position),this.container.size)}}z.cache=new Map;class C{constructor(t,e){this.execute=t,this.onSchedule=e,this.conditions=[]}schedule(t){s(t)&&(this.conditions=[],t=()=>!0),this.conditions.push(t),this.onSchedule()}resetConditions(){this.conditions=[]}get conditionsMet(){return this.conditions.some((t=>t()))}}class j{constructor(t){this.executeThrottled=p(this.execute.bind(this)),this.commands=Object.entries(t).reduce(((t,[e,s])=>Object.assign(Object.assign({},t),{[e]:new C(s,this.executeThrottled)})),{})}execute(){Object.values(this.commands).forEach((t=>{t.conditionsMet&&t.execute(),t.resetConditions()}))}cancel(){this.executeThrottled.cancel()}}const y={element:null,scrollParent:window,vertical:!0,triggerStart:null,triggerEnd:null,elementStart:0,elementEnd:0},B={default:t=>t,fallback:()=>0},k={start:"top",end:"bottom",size:"height",clientSize:"clientHeight",scrollSize:"scrollHeight",scrollDelta:"deltaY"},x={start:"left",end:"right",size:"width",clientSize:"clientWidth",scrollSize:"scrollWidth",scrollDelta:"deltaX"},L=t=>t?k:x,M=(t,e)=>Object.entries(L(t)).reduce(((t,[s,i])=>Object.assign(Object.assign({},t),{[s]:e[i]})),{}),R=(t,e,s=((t,e,s)=>`Invalid value ${t} for ${e}. ${s}`))=>Object.keys(t).reduce(((i,n)=>{var r;const o=n,c=t[o],a=e[o];let l;try{l=null!==(r=null==a?void 0:a(c))&&void 0!==r?r:c}catch(t){throw P(s(c,o,t.message))}return i[o]=l,i}),{}),I=t=>100*t+"%",T=([t,e])=>"px"===e?()=>t:e=>t/100*e,D=s=>{if(t(s))return()=>s;if(e(s)){if("center"===s){return T([50,"%"])}return(t=>{const e=t.match(/^([+-])?(\d+|\d*[.]\d+)(%|px)$/);if(i(e))throw P("String value must be number with unit, i.e. 20px or 80% or 'center' (=50%)");const[,s,n,r]=e;return T([parseFloat(`${null!=s?s:""}${n}`),r])})(s)}let n;try{n=t(s(1))}catch(t){throw P("Unsupported value type")}if(!n)throw P("Function must return a number");return s},H=t=>{const s=e(t)?(t=>{const e=document.querySelector(t);if(i(e))throw P("No element found for selector "+t);return e})(t):t,{body:n}=window.document;if(!r(s)&&!o(s)||!n.contains(s))throw P("Invalid element supplied");return s},W=t=>e=>i(e)?e:t(e),F=(t,e)=>i(t)||s(t)?e():t,$={element:W(H),scrollParent:t=>{if(n(t)||t instanceof Document)return window;const e=H(t);if(o(e))throw P("Can't use SVG as scrollParent");return e},vertical:t=>!!t,triggerStart:W(D),triggerEnd:W(D),elementStart:D,elementEnd:D},V=t=>((t,e,s=(t=>{O(`Unknown property ${t} will be disregarded`)}))=>Object.entries(t).reduce(((t,[i,n])=>i in e==0?(null==s||s(i),t):(t[i]=n,t)),{}))(t,y),U=(t,e)=>{const s=V(t),c=R(s,$);const a=(t=>{const{scrollParent:e,element:s}=t,c=t=>F(t,(()=>i(s)?B.fallback:B.default));return R(t,{element:t=>F(t,(()=>{const t=n(e)?document.body:e.firstElementChild;if(i(t)||!r(t)&&!o(t))throw P("Could not autodetect element, as scrollParent has no valid children.");return t})),triggerStart:c,triggerEnd:c})})(Object.assign(Object.assign({},e),c));return(t=>{const{triggerStart:e,triggerEnd:s,elementStart:i,elementEnd:n,vertical:r,scrollParent:o}=t,{size:c}=X(t),{clientSize:a}=M(r,l(o));c-i(c)-n(c)-(a-e(a)-s(a))<0&&O("Detected no overlap with the configured track options. This means ScrollMagic will not trigger unless this changes later on (i.e. due to resizes).",Object.assign(Object.assign({},t),{triggerStart:e(c),triggerEnd:s(c),elementStart:i(c),elementEnd:n(c)}))})(a),{sanitized:s,processed:a}},X=({vertical:t,element:e})=>M(t,e.getBoundingClientRect());var Y,A,Q;!function(t){t.Enter="enter",t.Leave="leave",t.Progress="progress"}(Y||(Y={})),function(t){t.Start="start",t.Inside="inside",t.End="end"}(A||(A={})),function(t){t.Forward="forward",t.Reverse="reverse"}(Q||(Q={}));class q{constructor(t,e,s){this.target=t,this.type=e,this.location=Y.Progress===e?A.Inside:Y.Enter===e&&s||Y.Leave===e&&!s?A.Start:A.End,this.direction=s?Q.Forward:Q.Reverse}}const G=(t,[e,s])=>Object.assign(Object.assign({},t),{[e]:s}),N=(t,e)=>Object.entries(t).filter((([t,s])=>s!==e[t])).reduce(G,{}),J=(t,e)=>parseFloat(t.toFixed(e)),K=({top:t,right:e,bottom:s,left:i})=>[t,e,s,i].join(" ");class Z{constructor(t,e){this.callback=t,this.options={root:null,margin:{top:"0px",right:"0px",bottom:"0px",left:"0px"}},this.observedElements=new Map,s(e)||(this.options=Object.assign(Object.assign({},this.options),e))}observerCallback(t,e){t.forEach((({target:t,isIntersecting:i})=>{var n;let[r,o]=null!==(n=this.observedElements.get(t))&&void 0!==n?n:[];const c=r&&o;e===this.observerEnter?r=i:o=i,this.observedElements.set(t,[r,o]);const a=r&&o;s(a)||c===a||this.callback(a,t)}))}createObserver(t){const e=this.options.root,s=new IntersectionObserver(this.observerCallback.bind(this),{root:e,rootMargin:t});return[...this.observedElements.keys()].forEach((t=>s.observe(t))),s}rebuildObserver(){var t,e;null===(t=this.observerEnter)||void 0===t||t.disconnect(),null===(e=this.observerLeave)||void 0===e||e.disconnect();const{margin:s}=this.options,i=t=>Math.max(0,parseFloat(t))+"%",n=Object.assign(Object.assign({},s),{top:i(s.top)}),r=Object.assign(Object.assign({},s),{bottom:i(s.bottom)});this.observerEnter=this.createObserver(K(n)),this.observerLeave=this.createObserver(K(r))}optionsChanged({root:t,margin:e}){return!s(t)&&t!==this.options.root||!s(e)&&Object.keys(N(e,this.options.margin)).length>0}modify(t){return this.optionsChanged(t)?(this.options=Object.assign(Object.assign({},this.options),t),this.rebuildObserver(),this):this}observe(t){var e,s;return this.observedElements.has(t)||(this.observedElements.set(t,[void 0,void 0]),null===(e=this.observerEnter)||void 0===e||e.observe(t),null===(s=this.observerLeave)||void 0===s||s.observe(t)),this}unobserve(t){var e,s;return this.observedElements.delete(t)&&(null===(e=this.observerEnter)||void 0===e||e.unobserve(t),null===(s=this.observerLeave)||void 0===s||s.unobserve(t)),this}disconnect(){var t,e;this.observedElements.clear(),null===(t=this.observerEnter)||void 0===t||t.disconnect(),null===(e=this.observerLeave)||void 0===e||e.disconnect()}}class _{constructor(t={}){this.name="ScrollMagic",this.dispatcher=new c,this.container=new z(this),this.resizeObserver=new ResizeObserver(p(this.onElementResize.bind(this))),this.viewportObserver=new Z(this.onIntersectionChange.bind(this)),this.executionQueue=new j({elementBounds:this.updateElementBoundsCache.bind(this),containerBounds:this.updateContainerBoundsCache.bind(this),viewportObserver:this.updateViewportObserver.bind(this),progress:this.updateProgress.bind(this)}),this.update=this.executionQueue.commands,this.plugins=new Set,this.elementBoundsCache={start:0,size:0,offsetStart:0,offsetEnd:0,trackSize:0},this.containerBoundsCache={clientSize:0,offsetStart:0,offsetEnd:0,trackSize:0,scrollSize:0},this.currentProgress=0;const e=Object.assign(Object.assign({},_.defaultOptionsPublic),t);this.modify(e)}getViewportMargin(){const{vertical:t}=this.optionsPrivate,{start:e,end:s}=L(t),{start:i,end:n}=L(!t),{scrollSize:r,clientSize:o}=M(!t,this.container.rect),{clientSize:c,offsetStart:a,offsetEnd:l}=this.containerBoundsCache,{offsetStart:h,offsetEnd:d}=this.elementBoundsCache,u=c-l+d,g=c<=0,p=g?0:-J((c-a+h)/c,5),b=g?0:-J(u/c,5),v=o<=0?0:I((r-o)/o);return{[s]:I(p),[e]:I(b),[i]:v,[n]:v}}getTrackSize(){return this.elementBoundsCache.trackSize+this.containerBoundsCache.trackSize}updateIntersectingState(t){this.intersecting=t}updateElementBoundsCache(){const{elementStart:t,elementEnd:e,element:s,vertical:i}=this.optionsPrivate,{start:n,size:r}=M(i,s.getBoundingClientRect()),o=t(r),c=e(r);this.elementBoundsCache={start:n,size:r,offsetStart:o,offsetEnd:c,trackSize:r-o-c}}updateContainerBoundsCache(){const{triggerStart:t,triggerEnd:e,vertical:s}=this.optionsPrivate,{clientSize:i,scrollSize:n}=M(s,this.container.rect),r=t(i),o=e(i);this.containerBoundsCache={clientSize:i,scrollSize:n,offsetStart:r,offsetEnd:o,trackSize:-(i-r-o)}}updateProgress(){const{offsetStart:t,start:e}=this.elementBoundsCache,{offsetStart:s}=this.containerBoundsCache,{start:i}=M(this.optionsPrivate.vertical,this.container.rect),n=i+s-(e+t),r=this.getTrackSize();if(r<0)return;const o=this.currentProgress,c=Math.min(Math.max(n/r,0),1),a=c-o;if(0===a)return;this.currentProgress=c;const l=a>0;0!==o&&1!==o||this.triggerEvent(Y.Enter,l),this.triggerEvent(Y.Progress,l),0!==c&&1!==c||this.triggerEvent(Y.Leave,l)}updateViewportObserver(){const{scrollParent:t}=this.optionsPrivate,e={margin:this.getViewportMargin(),root:n(t)?null:t};this.viewportObserver.modify(e)}onOptionChanges(t){const e=Object.keys(t);if(0===e.length)return;const s=e.includes.bind(e),i=s("elementStart"),n=s("elementEnd"),r=s("element"),o=s("scrollParent"),c=s("triggerStart"),a=s("triggerEnd"),l=s("vertical");if((i||n||r)&&(this.update.elementBounds.schedule(),r)){this.updateIntersectingState(void 0);const{element:t}=this.optionsPrivate;this.viewportObserver.disconnect(),this.viewportObserver.observe(t),this.resizeObserver.disconnect(),this.resizeObserver.observe(t)}(o||c||a||l)&&(this.update.viewportObserver.schedule(),o&&(this.update.containerBounds.schedule(),this.updateIntersectingState(void 0),this.container.attach(this.optionsPrivate.scrollParent,this.onContainerUpdate.bind(this)))),this.update.progress.schedule()}onElementResize(){const{update:t,elementBoundsCache:e}=this,{offsetStart:s,offsetEnd:i}=e,n=()=>s!==e.offsetStart||i!==e.offsetEnd;t.elementBounds.schedule(),t.viewportObserver.schedule(n),this.intersecting&&t.progress.schedule(n)}onContainerUpdate(t){const{update:e}=this;if("resize"===t.type){this.update.containerBounds.schedule(),this.intersecting&&e.elementBounds.schedule(),e.viewportObserver.schedule();const{start:t}=this.elementBoundsCache,s=()=>t!==this.elementBoundsCache.start;return void e.progress.schedule(s)}const{scrollDelta:s}=M(this.optionsPrivate.vertical,t.scrollDelta);if(0===s)return;const i=Math.abs(s)>this.getTrackSize();(this.intersecting||i)&&(e.elementBounds.schedule(),e.progress.schedule())}onIntersectionChange(t,e){e===this.optionsPrivate.element&&(this.updateIntersectingState(t),this.update.progress.schedule())}triggerEvent(t,e){this.dispatcher.dispatchEvent(new q(this,t,e))}modify(t){const{sanitized:e,processed:i}=U(t,this.optionsPrivate),n=s(this.optionsPublic)?e:N(e,this.optionsPublic);return this.optionsPublic=Object.assign(Object.assign({},this.optionsPublic),n),this.optionsPrivate=i,this.onOptionChanges(n),this.plugins.forEach((t=>{var e;return null===(e=t.onModify)||void 0===e?void 0:e.call(this,n)})),this}addPlugin(t){var e;return this.plugins.add(t),null===(e=t.onAdd)||void 0===e||e.call(this),this}removePlugin(t){var e;return this.plugins.delete(t),null===(e=t.onRemove)||void 0===e||e.call(this),this}set element(t){this.modify({element:t})}get element(){return this.optionsPublic.element}set scrollParent(t){this.modify({scrollParent:t})}get scrollParent(){return this.optionsPublic.scrollParent}set vertical(t){this.modify({vertical:t})}get vertical(){return this.optionsPublic.vertical}set triggerStart(t){this.modify({triggerStart:t})}get triggerStart(){return this.optionsPublic.triggerStart}set triggerEnd(t){this.modify({triggerEnd:t})}get triggerEnd(){return this.optionsPublic.triggerEnd}set elementStart(t){this.modify({elementStart:t})}get elementStart(){return this.optionsPublic.elementStart}set elementEnd(t){this.modify({elementEnd:t})}get elementEnd(){return this.optionsPublic.elementEnd}get progress(){return this.currentProgress}get scrollOffset(){this.updateElementBoundsCache();const{scrollParent:t,vertical:e}=this.optionsPrivate,{start:s,offsetStart:i,trackSize:n}=this.elementBoundsCache,{clientSize:r,offsetStart:o,offsetEnd:c}=this.containerBoundsCache,{start:a}=M(e,u(t)),l=s+a+i,h=l+n;return{start:Math.floor(l-o),end:Math.ceil(h-r+c)}}get computedOptions(){const{offsetStart:t,offsetEnd:e}=this.containerBoundsCache,{offsetStart:s,offsetEnd:i}=this.elementBoundsCache;return Object.assign(Object.assign({},this.optionsPrivate),{triggerStart:t,triggerEnd:e,elementStart:s,elementEnd:i})}get pluginList(){return[...this.plugins]}on(t,e){return this.dispatcher.addEventListener(t,e),this}off(t,e){return this.dispatcher.removeEventListener(t,e),this}subscribe(t,e){return this.dispatcher.addEventListener(t,e)}destroy(){this.executionQueue.cancel(),this.resizeObserver.disconnect(),this.viewportObserver.disconnect(),this.container.detach(),this.plugins.forEach(this.removePlugin.bind(this))}static defaultOptions(t={}){return this.defaultOptionsPublic=Object.assign(Object.assign({},this.defaultOptionsPublic),V(t)),this.defaultOptionsPublic}}_.defaultOptionsPublic=y,_.EventType=Y,_.EventLocation=A,_.EventScrollDirection=Q;export default _;
//# sourceMappingURL=scrollmagic.esm.js.map
