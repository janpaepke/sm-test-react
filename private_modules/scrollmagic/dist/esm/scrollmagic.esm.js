/*!
 * ScrollMagic v3.0.0-alpha
 * Author: Jan Paepke (https://janpaepke.de)
 * Contributors: Stefan Knop
 * Generated: 2021-05-23
 * License: (MIT OR GPL-3.0+)
 * Docs & Demos: https://scrollmagic.io
 */

const e=e=>"number"==typeof e,t=e=>"string"==typeof e,s=e=>void 0===e,i=e=>null===e,n=e=>e instanceof Window,r=e=>e instanceof HTMLElement,o=e=>e instanceof SVGElement;class c{constructor(){this.callbacks=new Map}addEventListener(e,t){let i=this.callbacks.get(e);return s(i)&&(i=[],this.callbacks.set(e,i)),i.push(t),()=>this.removeEventListener(e,t)}removeEventListener(e,t){const i=this.callbacks.get(e);if(s(i))return;const n=i.filter((e=>e!==t));this.callbacks.set(e,n)}dispatchEvent(e){const t=this.callbacks.get(e.type);s(t)||t.forEach((t=>t(e)))}}const a=(e,t)=>{let s=0;const i=function(...i){clearTimeout(s),s=window.setTimeout((()=>{s=0,e.apply(this,i)}),t)};return i.cancel=function(){clearTimeout(s),s=0},i},l=e=>{const t=n(e)?document.documentElement:e,{clientWidth:s,scrollHeight:i,scrollWidth:r}=t;let{clientHeight:o}=t;if(n(e)){const{innerHeight:t}=e;t-15>o&&(o=t)}return{clientWidth:s,clientHeight:o,scrollHeight:i,scrollWidth:r}},h=e=>n(e)?window.pageYOffset:e.scrollTop,d=e=>n(e)?window.pageXOffset:e.scrollLeft,u=e=>({left:d(e),top:h(e)}),g=(e,t,s,i)=>(e.addEventListener(t,s,i),e.removeEventListener.bind(e,t,s,i)),p=e=>{let t=0;const s=function(...s){0===t&&(t=requestAnimationFrame((()=>{t=0,e.apply(this,s)})))};return s.cancel=()=>{cancelAnimationFrame(t),t=0},s};var b;!function(e){e.Scroll="scroll",e.Resize="resize"}(b||(b={}));class v{constructor(e,t,s={deltaX:0,deltaY:0}){this.target=e,this.type=t,this.scrollDelta=s}}class f{constructor(e){this.scrollParent=e,this.dimensions={clientWidth:0,clientHeight:0,scrollWidth:0,scrollHeight:0},this.scrollPos={top:0,left:0},this.positionCache={top:0,left:0},this.dispatcher=new c,this.cleanups=[];const t=p(this.updateScrollPos.bind(this)),s=a(this.updateDimensions.bind(this),100);if(!n(e)){const e=p(this.updatePosition.bind(this));this.cleanups.push(e.cancel,this.subscribeMove(e))}this.cleanups.push(t.cancel,s.cancel,this.subscribeScroll(t),this.subscribeResize(s)),this.updateScrollPos(),this.updateDimensions()}updateScrollPos(){const e=this.scrollPos;this.scrollPos=u(this.scrollParent);const t=this.scrollPos.top-e.top,s=this.scrollPos.left-e.left;this.dispatcher.dispatchEvent(new v(this,b.Scroll,{deltaX:s,deltaY:t}))}updateDimensions(){this.dimensions=l(this.scrollParent),this.dispatcher.dispatchEvent(new v(this,b.Resize))}updatePosition(){const{top:e,left:t}=this.scrollParent.getBoundingClientRect();this.positionCache={top:e,left:t}}subscribeResize(e){const{scrollParent:t}=this;if(n(t))return g(t,b.Resize,e);const s=new ResizeObserver(e);return s.observe(t),()=>s.unobserve(t)}subscribeScroll(e){return g(this.scrollParent,b.Scroll,e)}subscribeMove(e){const t=[g(window,b.Scroll,e),g(window,b.Resize,e)];return()=>t.forEach((e=>e()))}subscribe(e,t){return this.dispatcher.addEventListener(e,t)}get size(){return this.dimensions}get position(){return this.positionCache}destroy(){this.cleanups.forEach((e=>e())),this.cleanups=[]}}const m="ScrollMagic";class E extends Error{constructor(e){super(e),this.name=m+"Error"}}class S extends E{constructor(e){super("Internal Error: "+e)}}const O=e=>new E(e),w=e=>new S(e),P=(e,...t)=>{null==console||console.warn(`${m} Warning: ${e}`,...t)};class z{constructor(e){this.scene=e,this.unsubscribers=[]}attach(e,t){s(this.container)||this.detach();let i=z.cache.get(e);s(i)&&(i=[new f(e),new Set],z.cache.set(e,i));const[n,r]=i;r.add(this.scene),this.container=n,this.unsubscribers=[n.subscribe("resize",t),n.subscribe("scroll",t)]}detach(){if(s(this.container))return;const{scrollParent:e}=this.container,t=z.cache.get(e);if(s(t))throw w("No cache info for scrollParent");const[i,n]=t;n.delete(this.scene),this.unsubscribers.forEach((e=>e())),this.unsubscribers=[],0===n.size&&(i.destroy(),z.cache.delete(e)),this.container=void 0}get rect(){if(s(this.container))throw w("Can't get size when not attached to a container");return Object.assign(Object.assign({},this.container.position),this.container.size)}}z.cache=new Map;class C{constructor(e,t){this.execute=e,this.onSchedule=t,this.conditions=[]}schedule(e){s(e)&&(this.conditions=[],e=()=>!0),this.conditions.push(e),this.onSchedule()}resetConditions(){this.conditions=[]}get conditionsMet(){return this.conditions.some((e=>e()))}}class j{constructor(e){this.executeThrottled=p(this.execute.bind(this)),this.commands=Object.entries(e).reduce(((e,[t,s])=>Object.assign(Object.assign({},e),{[t]:new C(s,this.executeThrottled)})),{})}execute(){Object.values(this.commands).forEach((e=>{e.conditionsMet&&e.execute(),e.resetConditions()}))}cancel(){this.executeThrottled.cancel()}}const y={element:null,scrollParent:window,vertical:!0,triggerStart:null,triggerEnd:null,elementStart:0,elementEnd:0},B={default:e=>e,fallback:()=>0},k={start:"top",end:"bottom",size:"height",clientSize:"clientHeight",scrollSize:"scrollHeight",scrollDelta:"deltaY"},x={start:"left",end:"right",size:"width",clientSize:"clientWidth",scrollSize:"scrollWidth",scrollDelta:"deltaX"},L=e=>e?k:x,M=(e,t)=>Object.entries(L(e)).reduce(((e,[s,i])=>Object.assign(Object.assign({},e),{[s]:t[i]})),{}),R=(e,t,s=((e,t,s)=>`Invalid value ${e} for ${t}. ${s}`))=>Object.keys(e).reduce(((i,n)=>{var r;const o=n,c=e[o],a=t[o];let l;try{l=null!==(r=null==a?void 0:a(c))&&void 0!==r?r:c}catch(e){throw O(s(c,o,e.message))}return i[o]=l,i}),{}),I=e=>100*e+"%",T=([e,t])=>"px"===t?()=>e:t=>e/100*t,D=s=>{if(e(s))return()=>s;if(t(s)){if("center"===s){return T([50,"%"])}return(e=>{const t=e.match(/^([+-])?(\d+|\d*[.]\d+)(%|px)$/);if(i(t))throw O("String value must be number with unit, i.e. 20px or 80% or 'center' (=50%)");const[,s,n,r]=t;return T([parseFloat(`${null!=s?s:""}${n}`),r])})(s)}let n;try{n=e(s(1))}catch(e){throw O("Unsupported value type")}if(!n)throw O("Function must return a number");return s},H=e=>{const s=t(e)?(e=>{const t=document.querySelector(e);if(i(t))throw O("No element found for selector "+e);return t})(e):e,{body:n}=window.document;if(!r(s)&&!o(s)||!n.contains(s))throw O("Invalid element supplied");return s},W=e=>t=>i(t)?t:e(t),F=(e,t)=>i(e)||s(e)?t():e,$={element:W(H),scrollParent:e=>{if(n(e)||e instanceof Document)return window;const t=H(e);if(o(t))throw O("Can't use SVG as scrollParent");return t},vertical:e=>!!e,triggerStart:W(D),triggerEnd:W(D),elementStart:D,elementEnd:D},V=e=>((e,t,s=(e=>{P(`Unknown property ${e} will be disregarded`)}))=>Object.entries(e).reduce(((e,[i,n])=>i in t==0?(null==s||s(i),e):(e[i]=n,e)),{}))(e,y),U=(e,t)=>{const s=V(e),c=R(s,$);const a=(e=>{const{scrollParent:t,element:s}=e,c=e=>F(e,(()=>i(s)?B.fallback:B.default));return R(e,{element:e=>F(e,(()=>{const e=n(t)?document.body:t.firstElementChild;if(i(e)||!r(e)&&!o(e))throw O("Could not autodetect element, as scrollParent has no valid children.");return e})),triggerStart:c,triggerEnd:c})})(Object.assign(Object.assign({},t),c));return(e=>{const{triggerStart:t,triggerEnd:s,elementStart:i,elementEnd:n,vertical:r,scrollParent:o}=e,{size:c}=X(e),{clientSize:a}=M(r,l(o));c-i(c)-n(c)-(a-t(a)-s(a))<0&&P("Detected no overlap with the configured track options. This means ScrollMagic will not trigger unless this changes later on (i.e. due to resizes).",Object.assign(Object.assign({},e),{triggerStart:t(c),triggerEnd:s(c),elementStart:i(c),elementEnd:n(c)}))})(a),{sanitized:s,processed:a}},X=({vertical:e,element:t})=>M(e,t.getBoundingClientRect());var Y,Q,q;!function(e){e.Enter="enter",e.Leave="leave",e.Progress="progress"}(Y||(Y={})),function(e){e.Start="start",e.Inside="inside",e.End="end"}(Q||(Q={})),function(e){e.Forward="forward",e.Reverse="reverse"}(q||(q={}));class A{constructor(e,t,s){this.target=e,this.type=t,this.location=Y.Progress===t?Q.Inside:Y.Enter===t&&s||Y.Leave===t&&!s?Q.Start:Q.End,this.direction=s?q.Forward:q.Reverse}}const G=(e,[t,s])=>Object.assign(Object.assign({},e),{[t]:s}),N=(e,t)=>Object.entries(e).filter((([e,s])=>s!==t[e])).reduce(G,{}),J=(e,t)=>parseFloat(e.toFixed(t)),K=({top:e,right:t,bottom:s,left:i})=>[e,t,s,i].join(" ");class Z{constructor(e,t){this.callback=e,this.options={root:null,margin:{top:"0px",right:"0px",bottom:"0px",left:"0px"}},this.observedElements=new Map,s(t)||(this.options=Object.assign(Object.assign({},this.options),t))}observerCallback(e,t){e.forEach((({target:e,isIntersecting:i})=>{var n;let[r,o]=null!==(n=this.observedElements.get(e))&&void 0!==n?n:[];const c=r&&o;t===this.observerEnter?r=i:o=i,this.observedElements.set(e,[r,o]);const a=r&&o;s(a)||c===a||this.callback(a,e)}))}createObserver(e){const t=this.options.root,s=new IntersectionObserver(this.observerCallback.bind(this),{root:t,rootMargin:e});return[...this.observedElements.keys()].forEach((e=>s.observe(e))),s}rebuildObserver(){var e,t;null===(e=this.observerEnter)||void 0===e||e.disconnect(),null===(t=this.observerLeave)||void 0===t||t.disconnect();const{margin:s}=this.options,i=e=>Math.max(0,parseFloat(e))+"%",n=Object.assign(Object.assign({},s),{top:i(s.top)}),r=Object.assign(Object.assign({},s),{bottom:i(s.bottom)});this.observerEnter=this.createObserver(K(n)),this.observerLeave=this.createObserver(K(r))}optionsChanged({root:e,margin:t}){return!s(e)&&e!==this.options.root||!s(t)&&Object.keys(N(t,this.options.margin)).length>0}modify(e){return this.optionsChanged(e)?(this.options=Object.assign(Object.assign({},this.options),e),this.rebuildObserver(),this):this}observe(e){var t,s;return this.observedElements.has(e)||(this.observedElements.set(e,[void 0,void 0]),null===(t=this.observerEnter)||void 0===t||t.observe(e),null===(s=this.observerLeave)||void 0===s||s.observe(e)),this}unobserve(e){var t,s;return this.observedElements.has(e)&&(this.observedElements.delete(e),null===(t=this.observerEnter)||void 0===t||t.unobserve(e),null===(s=this.observerLeave)||void 0===s||s.unobserve(e)),this}disconnect(){var e,t;this.observedElements.clear(),null===(e=this.observerEnter)||void 0===e||e.disconnect(),null===(t=this.observerLeave)||void 0===t||t.disconnect()}}class _{constructor(e={}){this.name="ScrollMagic",this.dispatcher=new c,this.container=new z(this),this.resizeObserver=new ResizeObserver(p(this.onElementResize.bind(this))),this.viewportObserver=new Z(this.onIntersectionChange.bind(this)),this.executionQueue=new j({elementBounds:this.updateElementBoundsCache.bind(this),containerBounds:this.updateContainerBoundsCache.bind(this),viewportObserver:this.updateViewportObserver.bind(this),progress:this.updateProgress.bind(this)}),this.update=this.executionQueue.commands,this.elementBoundsCache={start:0,size:0,offsetStart:0,offsetEnd:0,trackSize:0},this.containerBoundsCache={clientSize:0,offsetStart:0,offsetEnd:0,trackSize:0,scrollSize:0},this.currentProgress=0;const t=Object.assign(Object.assign({},_.defaultOptionsPublic),e);this.modify(t)}getViewportMargin(){const{vertical:e}=this.optionsPrivate,{start:t,end:s}=L(e),{start:i,end:n}=L(!e),{scrollSize:r,clientSize:o}=M(!e,this.container.rect),{clientSize:c,offsetStart:a,offsetEnd:l}=this.containerBoundsCache,{offsetStart:h,offsetEnd:d}=this.elementBoundsCache,u=c-l+d,g=c<=0,p=g?0:-J((c-a+h)/c,5),b=g?0:-J(u/c,5),v=o<=0?0:I((r-o)/o);return{[s]:I(p),[t]:I(b),[i]:v,[n]:v}}getTrackSize(){return this.elementBoundsCache.trackSize+this.containerBoundsCache.trackSize}updateIntersectingState(e){this.intersecting=e}updateElementBoundsCache(){const{elementStart:e,elementEnd:t,element:s,vertical:i}=this.optionsPrivate,{start:n,size:r}=M(i,s.getBoundingClientRect()),o=e(r),c=t(r);this.elementBoundsCache={start:n,size:r,offsetStart:o,offsetEnd:c,trackSize:r-o-c}}updateContainerBoundsCache(){const{triggerStart:e,triggerEnd:t,vertical:s}=this.optionsPrivate,{clientSize:i,scrollSize:n}=M(s,this.container.rect),r=e(i),o=t(i);this.containerBoundsCache={clientSize:i,scrollSize:n,offsetStart:r,offsetEnd:o,trackSize:-(i-r-o)}}updateProgress(){const{offsetStart:e,start:t}=this.elementBoundsCache,{offsetStart:s}=this.containerBoundsCache,{start:i}=M(this.optionsPrivate.vertical,this.container.rect),n=i+s-(t+e),r=this.getTrackSize();if(r<0)return;const o=this.currentProgress,c=Math.min(Math.max(n/r,0),1),a=c-o;if(0===a)return;this.currentProgress=c;const l=a>0;0!==o&&1!==o||this.triggerEvent(Y.Enter,l),this.triggerEvent(Y.Progress,l),0!==c&&1!==c||this.triggerEvent(Y.Leave,l)}updateViewportObserver(){const{scrollParent:e}=this.optionsPrivate,t={margin:this.getViewportMargin(),root:n(e)?null:e};this.viewportObserver.modify(t)}onOptionChanges(e){if(0===e.length)return;const t=e.includes.bind(e),s=t("elementStart"),i=t("elementEnd"),n=t("element"),r=t("scrollParent"),o=t("triggerStart"),c=t("triggerEnd"),a=t("vertical");if((s||i||n)&&(this.update.elementBounds.schedule(),n)){this.updateIntersectingState(void 0);const{element:e}=this.optionsPrivate;this.viewportObserver.disconnect(),this.viewportObserver.observe(e),this.resizeObserver.disconnect(),this.resizeObserver.observe(e)}(r||o||c||a)&&(this.update.viewportObserver.schedule(),r&&(this.update.containerBounds.schedule(),this.updateIntersectingState(void 0),this.container.attach(this.optionsPrivate.scrollParent,this.onContainerUpdate.bind(this)))),this.update.progress.schedule()}onElementResize(){const{update:e,elementBoundsCache:t}=this,{offsetStart:s,offsetEnd:i}=t,n=()=>s!==t.offsetStart||i!==t.offsetEnd;e.elementBounds.schedule(),e.viewportObserver.schedule(n),this.intersecting&&e.progress.schedule(n)}onContainerUpdate(e){const{update:t}=this;if("resize"===e.type){this.update.containerBounds.schedule(),this.intersecting&&t.elementBounds.schedule(),t.viewportObserver.schedule();const{start:e}=this.elementBoundsCache,s=()=>e!==this.elementBoundsCache.start;return void t.progress.schedule(s)}const{scrollDelta:s}=M(this.optionsPrivate.vertical,e.scrollDelta);if(0===s)return;const i=Math.abs(s)>this.getTrackSize();(this.intersecting||i)&&(t.elementBounds.schedule(),t.progress.schedule())}onIntersectionChange(e,t){t===this.optionsPrivate.element&&(this.updateIntersectingState(e),this.update.progress.schedule())}triggerEvent(e,t){this.dispatcher.dispatchEvent(new A(this,e,t))}modify(e){const{sanitized:t,processed:i}=U(e,this.optionsPrivate),n=s(this.optionsPrivate)?i:N(t,this.optionsPublic),r=Object.keys(n);return this.optionsPublic=Object.assign(Object.assign({},this.optionsPublic),t),this.optionsPrivate=i,this.onOptionChanges(r),this}set element(e){this.modify({element:e})}get element(){return this.optionsPublic.element}set scrollParent(e){this.modify({scrollParent:e})}get scrollParent(){return this.optionsPublic.scrollParent}set vertical(e){this.modify({vertical:e})}get vertical(){return this.optionsPublic.vertical}set triggerStart(e){this.modify({triggerStart:e})}get triggerStart(){return this.optionsPublic.triggerStart}set triggerEnd(e){this.modify({triggerEnd:e})}get triggerEnd(){return this.optionsPublic.triggerEnd}set elementStart(e){this.modify({elementStart:e})}get elementStart(){return this.optionsPublic.elementStart}set elementEnd(e){this.modify({elementEnd:e})}get elementEnd(){return this.optionsPublic.elementEnd}get progress(){return this.currentProgress}get scrollOffset(){this.updateElementBoundsCache();const{scrollParent:e,vertical:t}=this.optionsPrivate,{start:s,offsetStart:i,trackSize:n}=this.elementBoundsCache,{clientSize:r,offsetStart:o,offsetEnd:c}=this.containerBoundsCache,{start:a}=M(t,u(e)),l=s+a+i,h=l+n;return{start:Math.floor(l-o),end:Math.ceil(h-r+c)}}get computedOptions(){const{offsetStart:e,offsetEnd:t}=this.containerBoundsCache,{offsetStart:s,offsetEnd:i}=this.elementBoundsCache;return Object.assign(Object.assign({},this.optionsPrivate),{triggerStart:e,triggerEnd:t,elementStart:s,elementEnd:i})}on(e,t){return this.dispatcher.addEventListener(e,t),this}off(e,t){return this.dispatcher.removeEventListener(e,t),this}subscribe(e,t){return this.dispatcher.addEventListener(e,t)}destroy(){this.executionQueue.cancel(),this.resizeObserver.disconnect(),this.viewportObserver.disconnect(),this.container.detach()}static defaultOptions(e={}){return this.defaultOptionsPublic=Object.assign(Object.assign({},this.defaultOptionsPublic),V(e)),this.defaultOptionsPublic}}_.defaultOptionsPublic=y,_.EventType=Y,_.EventLocation=Q,_.EventScrollDirection=q;export default _;
//# sourceMappingURL=scrollmagic.esm.js.map
