{"version":3,"file":"scrollmagic.esm.js","sources":["../../src/util/typeguards.ts","../../src/EventDispatcher.ts","../../src/util/debounce.ts","../../src/util/getScrollContainerDimensions.ts","../../src/util/getScrollPos.ts","../../src/util/registerEvent.ts","../../src/util/throttleRaf.ts","../../src/Container.ts","../../src/ScrollMagicError.ts","../../src/ContainerProxy.ts","../../src/ExecutionQueue.ts","../../src/Options.ts","../../src/util/pickRelevantInfo.ts","../../src/util/processProperties.ts","../../src/util/transformers.ts","../../src/Options.processors.ts","../../src/util/sanitizeProperties.ts","../../src/ScrollMagicEvent.ts","../../src/util/pickDifferencesFlat.ts","../../src/util/roundToDecimals.ts","../../src/ViewportObserver.ts","../../src/ScrollMagic.ts"],"sourcesContent":["export const isNumber = (val: unknown): val is number => typeof val === 'number';\nexport const isString = (val: unknown): val is string => typeof val === 'string';\nexport const isUndefined = (val: unknown): val is undefined => undefined === val;\nexport const isNull = (val: unknown): val is null => null === val;\nexport const isWindow = (val: unknown): val is Window => val instanceof Window;\nexport const isDocument = (val: unknown): val is Document => val instanceof Document;\nexport const isHTMLElement = (val: unknown): val is HTMLElement => val instanceof HTMLElement;\nexport const isSVGElement = (val: unknown): val is SVGElement => val instanceof SVGElement;\n","import { isUndefined } from './util/typeguards';\n\ntype EventType = string;\nexport interface DispatchableEvent {\n\treadonly target: any;\n\treadonly type: EventType;\n}\n\ntype Callback<E extends DispatchableEvent> = (event: E) => void;\nexport class EventDispatcher {\n\tprivate callbacks = new Map<string, Callback<any>[]>();\n\n\t// adds a listener to the dispatcher. returns a function to reverse the effect.\n\tpublic addEventListener<T extends DispatchableEvent>(type: T['type'], cb: Callback<T>): () => void {\n\t\tlet list = this.callbacks.get(type);\n\t\tif (isUndefined(list)) {\n\t\t\tlist = [];\n\t\t\tthis.callbacks.set(type, list);\n\t\t}\n\t\tlist.push(cb);\n\t\treturn () => this.removeEventListener(type, cb);\n\t}\n\n\t// removes a listner from the dispatcher\n\tpublic removeEventListener<T extends DispatchableEvent>(type: T['type'], cb: Callback<T>): void {\n\t\tconst list = this.callbacks.get(type);\n\t\tif (isUndefined(list)) {\n\t\t\treturn;\n\t\t}\n\t\tconst remaining = list.filter(registeredCallback => registeredCallback !== cb);\n\t\tthis.callbacks.set(type, remaining);\n\t}\n\n\t// dispatches an event... DUH!\n\tpublic dispatchEvent(event: DispatchableEvent): void {\n\t\tconst list = this.callbacks.get(event.type);\n\t\tif (isUndefined(list)) {\n\t\t\treturn;\n\t\t}\n\t\tlist.forEach(cb => cb(event));\n\t}\n}\n","export const debounce = <F extends (...args: any) => ReturnType<F>>(func: F, wait: number) => {\n\tlet timeoutId = 0; // setTimeout returns positive integer, so 0 represents no call requested\n\n\tconst debounced = function (this: ThisParameterType<F>, ...args: Parameters<F>) {\n\t\tclearTimeout(timeoutId);\n\t\ttimeoutId = window.setTimeout(() => {\n\t\t\ttimeoutId = 0;\n\t\t\tfunc.apply(this, args);\n\t\t}, wait);\n\t};\n\n\tdebounced.cancel = function () {\n\t\tclearTimeout(timeoutId);\n\t\ttimeoutId = 0;\n\t};\n\n\treturn debounced as ((...args: Parameters<F>) => ReturnType<F>) & { cancel: () => void };\n};\n","import { isWindow } from './typeguards';\n\ninterface Dimensions {\n\treadonly clientWidth: number;\n\treadonly clientHeight: number;\n\treadonly scrollWidth: number;\n\treadonly scrollHeight: number;\n}\n\n// info limited to what we need...\nexport const getScrollContainerDimensions = (element: Window | Element): Dimensions => {\n\tconst elem = isWindow(element) ? document.documentElement : element;\n\tconst { clientWidth, scrollHeight, scrollWidth } = elem;\n\tlet { clientHeight } = elem;\n\tif (isWindow(element)) {\n\t\t// this is supposed to normalize for mobile, where the clientHeight excludes the menu bar, even when hidden after scroll\n\t\t// not sure how reliable this is, but so far it seems to work well\n\t\tconst { innerHeight } = element;\n\t\tif (innerHeight - 15 > clientHeight) {\n\t\t\tclientHeight = innerHeight;\n\t\t}\n\t}\n\treturn {\n\t\tclientWidth,\n\t\tclientHeight,\n\t\tscrollHeight,\n\t\tscrollWidth,\n\t};\n};\n","import { isWindow } from './typeguards';\n\nconst scrollTop = (container: Window | Element): number =>\n\tisWindow(container) ? window.pageYOffset : container.scrollTop;\n\nconst scrollLeft = (container: Window | Element): number =>\n\tisWindow(container) ? window.pageXOffset : container.scrollLeft;\n\nexport const getScrollPos = (container: Window | Element): { left: number; top: number } => ({\n\tleft: scrollLeft(container),\n\ttop: scrollTop(container),\n});\n","/**\n * Adds the passed listener as an event listener to the passed event target, and returns a function which reverses the\n * effect of this function.\n * @param {*} target object the listener should be attached to\n * @param {*} type type of listener\n * @param {*} listener callback\n * @param {*} options Event listener options\n */\nexport const registerEvent = (\n\ttarget: GlobalEventHandlers,\n\ttype: keyof (GlobalEventHandlersEventMap & WindowEventMap), // this does not catch if the wrong event is used on the wrong target, but should be stricter than 'string'\n\tlistener: EventListenerOrEventListenerObject,\n\toptions?: boolean | AddEventListenerOptions\n): (() => void) => {\n\ttarget.addEventListener(type, listener, options);\n\treturn target.removeEventListener.bind(target, type, listener, options);\n};\n","export const throttleRaf = <F extends (...a: any) => any>(\n\tfunc: F\n): ((this: ThisParameterType<F>, ...args: Parameters<F>) => void) & {\n\tcancel: () => void;\n} => {\n\tlet requestId = 0; // rAF returns non-zero values, so 0 represents no request pending\n\n\tconst scheduled = function (this: ThisParameterType<F>, ...args: Parameters<F>) {\n\t\tif (0 !== requestId) {\n\t\t\treturn;\n\t\t}\n\t\trequestId = requestAnimationFrame(() => {\n\t\t\trequestId = 0;\n\t\t\tfunc.apply(this, args);\n\t\t});\n\t};\n\n\tscheduled.cancel = () => {\n\t\tcancelAnimationFrame(requestId);\n\t\trequestId = 0;\n\t};\n\treturn scheduled;\n};\n","import { DispatchableEvent, EventDispatcher } from './EventDispatcher';\nimport { debounce } from './util/debounce';\nimport { getScrollContainerDimensions } from './util/getScrollContainerDimensions';\nimport { getScrollPos } from './util/getScrollPos';\nimport { registerEvent } from './util/registerEvent';\nimport { throttleRaf } from './util/throttleRaf';\nimport { isWindow } from './util/typeguards';\n\nexport type ScrollParent = HTMLElement | Window;\n\ntype CleanUpFunction = () => void;\ntype ScrollDelta = {\n\tdeltaX: number;\n\tdeltaY: number;\n};\n\n// type EventType = 'scroll' | 'resize';\nenum EventType {\n\tScroll = 'scroll',\n\tResize = 'resize',\n}\nexport class ContainerEvent implements DispatchableEvent {\n\tconstructor(\n\t\tpublic readonly target: Container,\n\t\tpublic readonly type: `${EventType}`,\n\t\tpublic readonly scrollDelta: ScrollDelta = { deltaX: 0, deltaY: 0 } // I could make an additional EventType only for Scroll Events, but we'll just ignore these for resize evnents...\n\t) {}\n}\n\nexport class Container {\n\tprivate dimensions = {\n\t\t// inner size excluding scrollbars\n\t\tclientWidth: 0,\n\t\tclientHeight: 0,\n\t\t// size of scrollable content\n\t\tscrollWidth: 0,\n\t\tscrollHeight: 0,\n\t};\n\tprivate scrollPos = {\n\t\ttop: 0,\n\t\tleft: 0,\n\t};\n\tprivate positionCache = {\n\t\t// position of scroll parent (if not window) relative to window\n\t\ttop: 0,\n\t\tleft: 0,\n\t};\n\tprivate dispatcher = new EventDispatcher();\n\tprivate cleanups = new Array<CleanUpFunction>();\n\t/**\n\t * TODO: Currently we have no way of detecting, when physical scrollbars appear or disappear, which should technically trigger a resize event.\n\t * One potential way of getting around this would be to add an additional resize observer to the documentElement and detect when it crosses 100% of the container's client size (either in or out)\n\t * But this seems quite hacky and code intense for this edge case scenario. It would also work for document scrolls, not for Element scrolls.\n\t */\n\tconstructor(public readonly scrollParent: ScrollParent) {\n\t\tconst throttledScroll = throttleRaf(this.updateScrollPos.bind(this));\n\t\tconst debouncedResize = debounce(this.updateDimensions.bind(this), 100);\n\t\tif (!isWindow(scrollParent)) {\n\t\t\tconst throttledMove = throttleRaf(this.updatePosition.bind(this));\n\t\t\tthis.cleanups.push(throttledMove.cancel, this.subscribeMove(throttledMove));\n\t\t}\n\t\tthis.cleanups.push(\n\t\t\tthrottledScroll.cancel,\n\t\t\tdebouncedResize.cancel,\n\t\t\tthis.subscribeScroll(throttledScroll),\n\t\t\tthis.subscribeResize(debouncedResize)\n\t\t);\n\t\tthis.updateScrollPos();\n\t\tthis.updateDimensions();\n\t}\n\n\tprivate updateScrollPos() {\n\t\tconst prevScrollPos = this.scrollPos;\n\t\tthis.scrollPos = getScrollPos(this.scrollParent);\n\t\tconst deltaY = this.scrollPos.top - prevScrollPos.top;\n\t\tconst deltaX = this.scrollPos.left - prevScrollPos.left;\n\t\tthis.dispatcher.dispatchEvent(new ContainerEvent(this, EventType.Scroll, { deltaX, deltaY }));\n\t}\n\n\tprivate updateDimensions() {\n\t\tthis.dimensions = getScrollContainerDimensions(this.scrollParent);\n\t\tthis.dispatcher.dispatchEvent(new ContainerEvent(this, EventType.Resize));\n\t}\n\n\tprivate updatePosition() {\n\t\t// this should only be executed, when scrollParent is NOT window\n\t\tconst { top, left } = (this.scrollParent as HTMLElement).getBoundingClientRect();\n\t\tthis.positionCache = { top, left };\n\t}\n\n\t// subscribes to resize events of scrollParent and returns a function to reverse the effect\n\tprivate subscribeResize(onResize: () => void) {\n\t\tconst { scrollParent } = this;\n\t\tif (isWindow(scrollParent)) {\n\t\t\treturn registerEvent(scrollParent, EventType.Resize, onResize);\n\t\t}\n\t\tconst observer = new ResizeObserver(onResize);\n\t\tobserver.observe(scrollParent);\n\t\treturn () => observer.unobserve(scrollParent);\n\t}\n\n\t// subscribes to scroll events of scrollParent and returns a function to reverse the effect\n\tprivate subscribeScroll(onScroll: () => void) {\n\t\treturn registerEvent(this.scrollParent, EventType.Scroll, onScroll);\n\t}\n\n\tprivate subscribeMove(onMove: () => void) {\n\t\tconst listeners = [\n\t\t\tregisterEvent(window, EventType.Scroll, onMove),\n\t\t\tregisterEvent(window, EventType.Resize, onMove),\n\t\t];\n\t\treturn () => listeners.forEach(cleanup => cleanup());\n\t}\n\n\t// subscribes Container and returns a function to reverse the effect\n\tpublic subscribe(type: `${EventType}`, cb: (e: ContainerEvent) => void): () => void {\n\t\treturn this.dispatcher.addEventListener(type, cb);\n\t}\n\n\tpublic get size(): Container['dimensions'] {\n\t\treturn this.dimensions;\n\t}\n\n\tpublic get position(): Container['positionCache'] {\n\t\treturn this.positionCache;\n\t}\n\n\tpublic destroy(): void {\n\t\tthis.cleanups.forEach(cleanup => cleanup());\n\t\tthis.cleanups = [];\n\t}\n}\n","const SM = 'ScrollMagic';\nexport class ScrollMagicError extends Error {\n\tpublic readonly name = `${SM}Error`;\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t}\n}\nexport class ScrollMagicErrorInternal extends ScrollMagicError {\n\tconstructor(message: string) {\n\t\tsuper(`Internal Error: ${message}`);\n\t}\n}\nexport const failWith = (message: string): ScrollMagicError => {\n\treturn new ScrollMagicError(message);\n};\nexport const failWithInternal = (message: string): ScrollMagicErrorInternal => {\n\treturn new ScrollMagicErrorInternal(message);\n};\nexport const warn = (first: unknown, ...args: unknown[]): void => {\n\tconsole?.warn(`${SM} Warning: ${first}`, ...args);\n};\n","import { Container, ContainerEvent, ScrollParent } from './Container';\nimport { ScrollMagic } from './ScrollMagic';\nimport { failWithInternal } from './ScrollMagicError';\nimport { isUndefined } from './util/typeguards';\n\ntype EventCallback = (e: ContainerEvent) => void;\ntype CleanUpFunction = () => void;\n\nexport class ContainerProxy {\n\tprivate static cache = new Map<ScrollParent, [Container, Set<ScrollMagic>]>();\n\n\tprivate container?: Container;\n\tconstructor(private readonly scene: ScrollMagic) {}\n\tprivate unsubscribers = new Array<CleanUpFunction>();\n\n\tpublic attach(scrollParent: ScrollParent, onUpdate: EventCallback): void {\n\t\tif (!isUndefined(this.container)) {\n\t\t\tthis.detach();\n\t\t}\n\t\tlet cache = ContainerProxy.cache.get(scrollParent);\n\t\tif (isUndefined(cache)) {\n\t\t\tcache = [new Container(scrollParent), new Set()];\n\t\t\tContainerProxy.cache.set(scrollParent, cache);\n\t\t}\n\t\tconst [container, scenes] = cache;\n\t\tscenes.add(this.scene);\n\t\tthis.container = container;\n\t\tthis.unsubscribers = [container.subscribe('resize', onUpdate), container.subscribe('scroll', onUpdate)];\n\t}\n\n\tpublic detach(): void {\n\t\tif (isUndefined(this.container)) {\n\t\t\treturn;\n\t\t}\n\t\tconst { scrollParent } = this.container;\n\t\tconst cache = ContainerProxy.cache.get(scrollParent);\n\t\tif (isUndefined(cache)) {\n\t\t\tthrow failWithInternal('No cache info for scrollParent');\n\t\t}\n\t\tconst [container, scenes] = cache;\n\t\tscenes.delete(this.scene);\n\t\tthis.unsubscribers.forEach(unsubscribe => unsubscribe());\n\t\tthis.unsubscribers = [];\n\t\tif (scenes.size === 0) {\n\t\t\t// no more attached scenes\n\t\t\tcontainer.destroy();\n\t\t\tContainerProxy.cache.delete(scrollParent);\n\t\t}\n\t\tthis.container = undefined;\n\t}\n\n\tpublic get rect(): Container['size'] & Container['position'] {\n\t\tif (isUndefined(this.container)) {\n\t\t\tthrow failWithInternal(`Can't get size when not attached to a container`);\n\t\t}\n\t\treturn {\n\t\t\t...this.container.position,\n\t\t\t...this.container.size,\n\t\t};\n\t}\n}\n","import { throttleRaf } from './util/throttleRaf';\nimport { isUndefined } from './util/typeguards';\n\ntype Command = () => void;\ntype ExecutionCondition = () => boolean;\ntype CommandList<T extends string> = Record<T, QueueItem>;\n\n/**\n * TODO! Update - this is very different now\n * Holds a list of commands and execute them in order.\n * If a command is added twice before executing, it will stay in the order position as before.\n * Caveats:\n * - can't override commands with existing precondition\n */\n\nclass QueueItem {\n\tprotected conditions: ExecutionCondition[] = [];\n\tconstructor(public readonly execute: Command, protected readonly onSchedule: () => void) {}\n\tpublic schedule(condition?: ExecutionCondition) {\n\t\tif (isUndefined(condition)) {\n\t\t\t// if no condition is provided, conditions are considered always met. Any conditions added after this won't even be run\n\t\t\tthis.conditions = [];\n\t\t\tcondition = () => true;\n\t\t}\n\t\tthis.conditions.push(condition);\n\t\tthis.onSchedule();\n\t}\n\tpublic resetConditions() {\n\t\tthis.conditions = [];\n\t}\n\tpublic get conditionsMet() {\n\t\treturn this.conditions.some(condition => condition());\n\t}\n}\n\nexport class ExecutionQueue<C extends string> {\n\tpublic readonly commands: CommandList<C>;\n\tprotected executeThrottled = throttleRaf(this.execute.bind(this));\n\n\tconstructor(queueItems: Record<C, Command>) {\n\t\tthis.commands = Object.entries<Command>(queueItems).reduce(\n\t\t\t(res, [name, command]) => ({\n\t\t\t\t...res,\n\t\t\t\t[name]: new QueueItem(command, this.executeThrottled),\n\t\t\t}),\n\t\t\t{} as CommandList<C>\n\t\t);\n\t}\n\n\t// executes all commands in the list in order, depending on wether or not their conditions are met\n\tpublic execute(): void {\n\t\tObject.values<QueueItem>(this.commands).forEach(item => {\n\t\t\tif (item.conditionsMet) {\n\t\t\t\titem.execute();\n\t\t\t}\n\t\t\titem.resetConditions();\n\t\t});\n\t}\n\tpublic cancel(): void {\n\t\tthis.executeThrottled.cancel();\n\t}\n}\n","type SameProperties<T extends { [K in keyof T]: unknown }, R extends { [K in keyof T]: unknown }> = R;\ntype ExtendProperty<T extends { [K in keyof T]: unknown }, K extends keyof T, E> = Omit<T, K> & { [X in K]: T[X] | E };\ntype ModifyProperty<T extends { [K in keyof T]: unknown }, K extends keyof T, E> = Omit<T, K> & { [X in K]: E };\ntype UnitString = `${number}px` | `${number}%`;\ntype CenterShorthand = 'center';\ntype CssSelector = string;\n\n// takes the width or height height of an element and returns the value that is used for position calculations\nexport type PixelConverter = (size: number) => number;\n\nexport type Public = {\n\telement?: Element | CssSelector | null;\n\tscrollParent?: Window | Document | Element | CssSelector;\n\tvertical?: boolean;\n\ttriggerStart?: number | UnitString | CenterShorthand | PixelConverter | null; // null means infer default values based on wether or not an element is supplied\n\ttriggerEnd?: number | UnitString | CenterShorthand | PixelConverter | null; // null means infer default values based on wether or not an element is supplied\n\telementStart?: number | UnitString | CenterShorthand | PixelConverter;\n\telementEnd?: number | UnitString | CenterShorthand | PixelConverter;\n};\n\n// basically a normalized version of the options\nexport type Private = SameProperties<\n\tPublic,\n\t{\n\t\telement: Element;\n\t\tscrollParent: Window | HTMLElement;\n\t\tvertical: boolean;\n\t\ttriggerStart: PixelConverter;\n\t\ttriggerEnd: PixelConverter;\n\t\telementStart: PixelConverter;\n\t\telementEnd: PixelConverter;\n\t}\n>;\n\n// values that can be null after processing and need to be inferred, if still null\nexport type PrivateUninferred = ExtendProperty<Private, 'triggerStart' | 'triggerEnd' | 'element', null>;\n// PixelConverters are executed and their values returned during computation\nexport type PrivateComputed = ModifyProperty<\n\tPrivate,\n\t'triggerStart' | 'triggerEnd' | 'elementStart' | 'elementEnd',\n\tnumber\n>;\n\n// default options\nexport const defaults: Required<Public> = {\n\telement: null,\n\tscrollParent: window,\n\tvertical: true,\n\ttriggerStart: null,\n\ttriggerEnd: null,\n\telementStart: 0,\n\telementEnd: 0,\n};\n\n// applied during fallback inference. if triggerStart or triggerEnd is null this will apply default if element is present and fallback otherwise\nexport const inferredTriggers: Record<string, PixelConverter> = {\n\tdefault: (scrollParentSize: number) => scrollParentSize, // default 100%, starts at bottom, ends at top\n\tfallback: () => 0, // if no element is supplied, it will fall back to the first child of scroll parent (usually the body), so it starts at the top and ends at the bottom\n};\n","const verticalProps = {\n\tstart: 'top',\n\tend: 'bottom',\n\tsize: 'height',\n\tclientSize: 'clientHeight',\n\tscrollSize: 'scrollHeight',\n\tscrollDelta: 'deltaY',\n} as const;\nconst horizontalProps = {\n\tstart: 'left',\n\tend: 'right',\n\tsize: 'width',\n\tclientSize: 'clientWidth',\n\tscrollSize: 'scrollWidth',\n\tscrollDelta: 'deltaX',\n} as const;\n\ntype VerticalProps = typeof verticalProps;\ntype HorizontalProps = typeof horizontalProps;\ntype Props = keyof VerticalProps & keyof HorizontalProps;\ntype SourceProps = VerticalProps[Props] | HorizontalProps[Props];\ntype RectInfo = Record<SourceProps, number>;\n\ntype MatchType<T, P, K extends keyof T & keyof P> = T[K] extends P[K] ? T[K] : undefined;\n\n/**\n * Returns the relevant property names depending on vertical or horizontal orientation.\n * @param vertical scrolldirection (true = vertical)\n */\nexport const pickRelevantProps = (vertical: boolean): VerticalProps | HorizontalProps =>\n\tvertical ? verticalProps : horizontalProps;\n/**\n * Returns the relevant boundary values depending on vertical or horizontal orientation.\n * I.E. top or left value => start, width / height => size.\n * @param obj Object to tretrieve the values from\n * @param vertical scrolldirection (true = vertical)\n */\nexport const pickRelevantValues = <T extends Partial<RectInfo>, V extends boolean>(\n\tvertical: V,\n\tobj: T\n\t// the idea with the return type is to make sure each property has the correct type based on the object that is passed in.\n\t// i.e. if both top and left exist -> number, if only top exists -> number | undefined, if neither exist -> undefined.\n): { [X in Props]: MatchType<T, RectInfo, VerticalProps[X]> | MatchType<T, RectInfo, HorizontalProps[X]> } =>\n\tObject.entries(pickRelevantProps(vertical)).reduce((res, [key, value]) => {\n\t\treturn {\n\t\t\t...res,\n\t\t\t[key]: obj[value],\n\t\t};\n\t}, {} as { [X in Props]: MatchType<T, RectInfo, VerticalProps[X]> | MatchType<T, RectInfo, HorizontalProps[X]> });\n","import { failWith } from '../ScrollMagicError';\n\n// type to ensure there's an output processor for every input\nexport type PropertyProcessors<I extends { [X in keyof I]: unknown }, O extends { [X in keyof I]: unknown }> = {\n\t[X in keyof I]: (value: Required<I>[X]) => O[X];\n};\n\n/**\n * A function that can be used to validate the properties of an object based on predefined rules.\n * @param obj the object that should be processed\n * @param processors an object with matching keys, which defines how to normalize and or validate a property\n * @param getErrorMessage A function that returns the format for the error message, should normalize or check fail.\n * @returns the normalized and checked object\n */\n\nexport const processProperties = <\n\tI extends { [X in keyof I]: any },\n\tP extends { [X in K]?: (value: Required<I>[X]) => any },\n\tO extends { [X in K]: P[X] extends (...args: any) => infer R ? R : I[X] },\n\tK extends keyof I\n>(\n\tobj: I,\n\tprocessors: P,\n\tgetErrorMessage: (value: unknown, prop: keyof I, reason?: string) => string = (value, prop, reason) =>\n\t\t`Invalid value ${value} for ${prop}. ${reason}`\n): O => {\n\treturn Object.keys(obj).reduce((result, key) => {\n\t\tconst prop = key as K;\n\t\tconst value = obj[prop];\n\t\tconst processor = processors[prop];\n\t\tlet processedValue: O[K];\n\t\ttry {\n\t\t\tprocessedValue = processor?.(value) ?? value;\n\t\t} catch (e) {\n\t\t\tthrow failWith(getErrorMessage(value, prop, e.message));\n\t\t}\n\t\tresult[prop] = processedValue;\n\t\treturn result;\n\t}, {} as O);\n};\n","import { failWith } from '../ScrollMagicError';\nimport {\n\tisDocument,\n\tisHTMLElement,\n\tisNull,\n\tisNumber,\n\tisSVGElement,\n\tisString,\n\tisUndefined,\n\tisWindow,\n} from './typeguards';\n\ntype PixelConverter = (size: number) => number;\ntype UnitString = `${number}px` | `${number}%`;\n\nconst centerShorthand = 'center';\n\nexport const numberToPercString = (val: number): string => `${val * 100}%`;\n\nconst unitTupleToPixelConverter = ([value, unit]: [number, 'px' | '%']): PixelConverter => {\n\treturn unit === 'px' ? () => value : (size: number) => (value / 100) * size;\n};\n\nexport const unitStringToPixelConverter = (val: UnitString): PixelConverter => {\n\tconst match = val.match(/^([+-])?(\\d+|\\d*[.]\\d+)(%|px)$/);\n\tif (isNull(match)) {\n\t\tthrow failWith(`String value must be number with unit, i.e. 20px or 80% or '${centerShorthand}' (=50%)`);\n\t}\n\tconst [, sign, digits, unit] = match as [string, '+' | '-' | null, string, 'px' | '%'];\n\treturn unitTupleToPixelConverter([parseFloat(`${sign ?? ''}${digits}`), unit]);\n};\n\nexport const toPixelConverter = (\n\tval: number | UnitString | typeof centerShorthand | PixelConverter\n): PixelConverter => {\n\tif (isNumber(val)) {\n\t\treturn () => val;\n\t}\n\tif (isString(val)) {\n\t\tif (centerShorthand === val) {\n\t\t\tconst x = unitTupleToPixelConverter([50, '%']);\n\t\t\treturn x;\n\t\t}\n\t\treturn unitStringToPixelConverter(val);\n\t}\n\t// ok, probably passed in function, let's see if it works.\n\tlet returnsNumber: boolean;\n\ttry {\n\t\treturnsNumber = isNumber(val(1));\n\t} catch (e) {\n\t\tthrow failWith('Unsupported value type');\n\t}\n\tif (!returnsNumber) {\n\t\tthrow failWith('Function must return a number');\n\t}\n\treturn val;\n};\n\nexport const selectorToSingleElement = (selector: string): Element => {\n\tconst elem = document.querySelector(selector);\n\tif (isNull(elem)) {\n\t\tthrow failWith(`No element found for selector ${selector}`);\n\t}\n\treturn elem;\n};\n\nexport const toSvgOrHtmlElement = (reference: Element | string): HTMLElement | SVGElement => {\n\tconst elem = isString(reference) ? selectorToSingleElement(reference) : reference;\n\tconst { body } = window.document;\n\tif (!(isHTMLElement(elem) || isSVGElement(elem)) || !body.contains(elem)) {\n\t\tthrow failWith('Invalid element supplied');\n\t}\n\treturn elem;\n};\n\nexport const toValidScrollParent = (container: Window | Document | Element | string): Window | HTMLElement => {\n\tif (isWindow(container) || isDocument(container)) {\n\t\treturn window;\n\t}\n\tconst elem = toSvgOrHtmlElement(container);\n\tif (isSVGElement(elem)) {\n\t\tthrow failWith(`Can't use SVG as scrollParent`);\n\t}\n\treturn elem;\n};\n\n// returns null if null is passed in or returns the return value of the function that's passed in.\nexport const nullPassThrough = <F extends (val: any) => any>(\n\tfunc: F\n): ((val: Parameters<F>[0] | null) => ReturnType<F> | null) => (val: Parameters<F>[0] | null) =>\n\tisNull(val) ? val : func(val);\n\n// checks if a value is null and returns it, if it is not.\n// if it is, it runs a function to recover a value\nexport const toNonNullable = <T extends unknown>(val: T, recover: () => NonNullable<T>): NonNullable<T> =>\n\tisNull(val) || isUndefined(val) ? recover() : (val as NonNullable<T>);\n\nexport const toBoolean = (val: unknown): boolean => !!val;\n","import {\n\tPixelConverter,\n\tPrivate,\n\tPrivateUninferred,\n\tPublic,\n\tinferredTriggers,\n\tdefaults as optionDefaults,\n} from './Options';\nimport { failWith, warn } from './ScrollMagicError';\nimport { getScrollContainerDimensions } from './util/getScrollContainerDimensions';\nimport { pickRelevantValues } from './util/pickRelevantInfo';\nimport { PropertyProcessors, processProperties } from './util/processProperties';\nimport { sanitizeProperties } from './util/sanitizeProperties';\nimport {\n\tnullPassThrough,\n\ttoBoolean,\n\ttoNonNullable,\n\ttoPixelConverter,\n\ttoSvgOrHtmlElement,\n\ttoValidScrollParent,\n} from './util/transformers';\nimport { isHTMLElement, isNull, isSVGElement, isWindow } from './util/typeguards';\n\nconst transformers: PropertyProcessors<Required<Public>, PrivateUninferred> = {\n\telement: nullPassThrough(toSvgOrHtmlElement),\n\tscrollParent: toValidScrollParent,\n\tvertical: toBoolean,\n\ttriggerStart: nullPassThrough(toPixelConverter),\n\ttriggerEnd: nullPassThrough(toPixelConverter),\n\telementStart: toPixelConverter,\n\telementEnd: toPixelConverter,\n};\n\n// removes unknown properties from supplied options\nexport const sanitize = <T extends Public>(options: T): T => sanitizeProperties(options, optionDefaults);\n\n// converts all public values to their corresponding private value, leaving null values untoched\nconst transform = (options: Public): Partial<PrivateUninferred> => processProperties(options, transformers);\n\n// processes remaining null values\nconst infer = (options: PrivateUninferred): Private => {\n\tconst { scrollParent, element } = options;\n\n\tconst inferElement = (elem: Element | null) =>\n\t\ttoNonNullable(elem, () => {\n\t\t\tconst elem = isWindow(scrollParent) ? document.body : scrollParent.firstElementChild;\n\t\t\tif (isNull(elem) || !(isHTMLElement(elem) || isSVGElement(elem))) {\n\t\t\t\tthrow failWith(`Could not autodetect element, as scrollParent has no valid children.`);\n\t\t\t}\n\t\t\treturn elem;\n\t\t});\n\n\tconst inferTrigger = (val: PixelConverter | null) =>\n\t\ttoNonNullable(val, () => (isNull(element) ? inferredTriggers.fallback : inferredTriggers.default));\n\n\treturn processProperties(options, {\n\t\telement: inferElement,\n\t\ttriggerStart: inferTrigger,\n\t\ttriggerEnd: inferTrigger,\n\t});\n};\n\n// checks if the options the user entered actually make sense\nconst check = (options: Private): void => {\n\tconst { triggerStart, triggerEnd, elementStart, elementEnd, vertical, scrollParent } = options;\n\tconst { size: elementSize } = getElementSize(options);\n\tconst { clientSize: containerSize } = pickRelevantValues(vertical, getScrollContainerDimensions(scrollParent));\n\n\tconst elementDistance = elementSize - elementStart(elementSize) - elementEnd(elementSize);\n\tconst trackDistance = -(containerSize - triggerStart(containerSize) - triggerEnd(containerSize));\n\n\tconst total = elementDistance + trackDistance;\n\tif (total < 0) {\n\t\twarn(\n\t\t\t'Detected no overlap with the configured track options. This means ScrollMagic will not trigger unless this changes later on (i.e. due to resizes).',\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\ttriggerStart: triggerStart(elementSize),\n\t\t\t\ttriggerEnd: triggerEnd(elementSize),\n\t\t\t\telementStart: elementStart(elementSize),\n\t\t\t\telementEnd: elementEnd(elementSize),\n\t\t\t}\n\t\t);\n\t}\n};\n\nexport const process = <T extends Public>(newOptions: T, oldOptions: Private): { sanitized: T; processed: Private } => {\n\tconst sanitized = sanitize(newOptions);\n\tconst normalized = transform(sanitized);\n\tconst processed = infer({ ...oldOptions, ...normalized });\n\tcheck(processed); // finally sanity check\n\treturn { sanitized, processed };\n};\n\n// helpers\nconst getElementSize = ({ vertical, element }: Pick<Private, 'vertical' | 'element'>) =>\n\tpickRelevantValues(vertical, element.getBoundingClientRect());\n","import { warn } from '../ScrollMagicError';\n\nexport const sanitizeProperties = <T extends Record<string, any>>(\n\tobj: T,\n\tdefaults: Record<string, any>,\n\tonUnknown = (propertyName: string) => {\n\t\twarn(`Unknown property ${propertyName} will be disregarded`);\n\t}\n): T =>\n\tObject.entries(obj).reduce((res, [key, value]) => {\n\t\tif (key in defaults === false) {\n\t\t\tonUnknown?.(key);\n\t\t\treturn res;\n\t\t}\n\t\tres[key as keyof T] = value;\n\t\treturn res;\n\t}, {} as T);\n","import { DispatchableEvent } from './EventDispatcher';\nimport { ScrollMagic } from './ScrollMagic';\n\nexport enum EventType {\n\tEnter = 'enter',\n\tLeave = 'leave',\n\tProgress = 'progress',\n}\n\nexport enum EventLocation {\n\tStart = 'start',\n\tInside = 'inside',\n\tEnd = 'end',\n}\n\nexport enum ScrollDirection {\n\tForward = 'forward',\n\tReverse = 'reverse',\n}\n\ntype EnumToLiteral<T extends string> = `${T}`;\ntype ScrollMagicEventType = EnumToLiteral<EventType>;\ntype ScrollMagicEventLocation = EnumToLiteral<EventLocation>;\ntype ScrollMagicEventScrollDirection = EnumToLiteral<ScrollDirection>;\n\nexport class ScrollMagicEvent implements DispatchableEvent {\n\tpublic readonly location: ScrollMagicEventLocation;\n\tpublic readonly direction: ScrollMagicEventScrollDirection;\n\tconstructor(\n\t\tpublic readonly target: ScrollMagic,\n\t\tpublic readonly type: ScrollMagicEventType,\n\t\tmovingForward: boolean\n\t) {\n\t\tthis.location = (() => {\n\t\t\tif (EventType.Progress === type) {\n\t\t\t\treturn EventLocation.Inside;\n\t\t\t}\n\t\t\tif ((EventType.Enter === type && movingForward) || (EventType.Leave === type && !movingForward)) {\n\t\t\t\treturn EventLocation.Start;\n\t\t\t}\n\t\t\treturn EventLocation.End;\n\t\t})();\n\t\tthis.direction = movingForward ? ScrollDirection.Forward : ScrollDirection.Reverse;\n\t}\n}\n","// Object.fromEntries replacement\nconst fromEntries = <T extends { [key: string]: any }>(obj: T, [key, value]: [string, any]) => ({\n\t...obj,\n\t[key]: value,\n});\n// checks an object against a reference object and returns a new object containing only differences in direct descendents (one way!)\nexport const pickDifferencesFlat = <T extends Record<string, any>>(part: Partial<T>, full: T): Partial<T> =>\n\tObject.entries(part)\n\t\t.filter(([key, value]) => value !== full[key])\n\t\t.reduce(fromEntries, {});\n","export const roundToDecimals = (val: number, decimals: number): number => parseFloat(val.toFixed(decimals));\n","import { pickDifferencesFlat } from './util/pickDifferencesFlat';\nimport { isUndefined } from './util/typeguards';\n\ntype Margin = {\n\ttop: string;\n\tright: string;\n\tbottom: string;\n\tleft: string;\n};\n\ninterface Options {\n\troot?: Element | null; // null is window\n\tmargin?: Margin;\n}\n\ntype ObserverCallback = (isIntersecting: boolean, target: Element) => void;\n\n// this ensures the order in the object doesn't matter\nconst marginObjToString = ({ top, right, bottom, left }: Margin) => [top, right, bottom, left].join(' ');\n\nconst none = '0px';\n\nexport class ViewportObserver {\n\tprivate observerEnter?: IntersectionObserver;\n\tprivate observerLeave?: IntersectionObserver;\n\tprivate options: Required<Options> = {\n\t\troot: null,\n\t\tmargin: { top: none, right: none, bottom: none, left: none },\n\t};\n\tprivate observedElements = new Map<Element, [boolean | undefined, boolean | undefined]>();\n\tconstructor(private callback: ObserverCallback, options?: Options) {\n\t\tif (isUndefined(options)) {\n\t\t\treturn; // nothing will happen, until modify is called.\n\t\t}\n\t\tthis.options = {\n\t\t\t...this.options,\n\t\t\t...options,\n\t\t};\n\t}\n\tprivate observerCallback(entries: IntersectionObserverEntry[], observer: IntersectionObserver) {\n\t\tentries.forEach(({ target, isIntersecting }) => {\n\t\t\tlet [hitEnter, hitLeave] = this.observedElements.get(target) ?? [];\n\t\t\tconst prevState = hitEnter && hitLeave;\n\t\t\tif (observer === this.observerEnter) {\n\t\t\t\thitEnter = isIntersecting;\n\t\t\t} else {\n\t\t\t\thitLeave = isIntersecting;\n\t\t\t}\n\t\t\tthis.observedElements.set(target, [hitEnter, hitLeave]);\n\t\t\tconst newState = hitEnter && hitLeave;\n\t\t\tif (isUndefined(newState) || prevState === newState) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.callback(newState, target);\n\t\t});\n\t}\n\tprivate createObserver(rootMargin: string) {\n\t\tconst root = this.options.root;\n\t\tconst observer = new IntersectionObserver(this.observerCallback.bind(this), { root, rootMargin });\n\t\t[...this.observedElements.keys()].forEach(elem => observer.observe(elem));\n\t\treturn observer;\n\t}\n\tprivate rebuildObserver() {\n\t\tthis.observerEnter?.disconnect();\n\t\tthis.observerLeave?.disconnect();\n\t\tconst { margin } = this.options;\n\t\tconst maxDimension = (val: string) => `${Math.max(0, parseFloat(val))}%`;\n\n\t\t// TODO: check what happens, if the opposite value still overlaps (due to offset / height ?)\n\t\t// TODO! I know now: if effective duration exceeds available observer height it fails... -> BUG! -> FIX...\n\t\tconst marginEnter = { ...margin, top: maxDimension(margin.top) };\n\t\tconst marginLeave = { ...margin, bottom: maxDimension(margin.bottom) };\n\n\t\tthis.observerEnter = this.createObserver(marginObjToString(marginEnter));\n\t\tthis.observerLeave = this.createObserver(marginObjToString(marginLeave));\n\t}\n\tprivate optionsChanged({ root, margin }: Options) {\n\t\tif (!isUndefined(root) && root !== this.options.root) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!isUndefined(margin)) {\n\t\t\treturn Object.keys(pickDifferencesFlat(margin, this.options.margin)).length > 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic modify(options: Options): ViewportObserver {\n\t\tif (!this.optionsChanged(options)) {\n\t\t\treturn this;\n\t\t}\n\t\tthis.options = {\n\t\t\t...this.options,\n\t\t\t...options,\n\t\t};\n\t\tthis.rebuildObserver();\n\t\treturn this;\n\t}\n\tpublic observe(elem: Element): ViewportObserver {\n\t\tif (!this.observedElements.has(elem)) {\n\t\t\tthis.observedElements.set(elem, [undefined, undefined]);\n\t\t\tthis.observerEnter?.observe(elem);\n\t\t\tthis.observerLeave?.observe(elem);\n\t\t}\n\t\treturn this;\n\t}\n\tpublic unobserve(elem: Element): ViewportObserver {\n\t\tif (this.observedElements.delete(elem)) {\n\t\t\tthis.observerEnter?.unobserve(elem);\n\t\t\tthis.observerLeave?.unobserve(elem);\n\t\t}\n\t\treturn this;\n\t}\n\tpublic disconnect(): void {\n\t\tthis.observedElements.clear();\n\t\tthis.observerEnter?.disconnect();\n\t\tthis.observerLeave?.disconnect();\n\t}\n}\n","import { ContainerEvent } from './Container';\nimport { ContainerProxy } from './ContainerProxy';\nimport { EventDispatcher } from './EventDispatcher';\nimport { ExecutionQueue } from './ExecutionQueue';\nimport * as Options from './Options';\nimport { process as processOptions, sanitize as sanitizeOptions } from './Options.processors';\nimport { EventLocation, EventType, ScrollDirection, ScrollMagicEvent } from './ScrollMagicEvent';\nimport { getScrollPos } from './util/getScrollPos';\nimport { pickDifferencesFlat } from './util/pickDifferencesFlat';\nimport { pickRelevantProps, pickRelevantValues } from './util/pickRelevantInfo';\nimport { roundToDecimals } from './util/roundToDecimals';\nimport { throttleRaf } from './util/throttleRaf';\nimport { numberToPercString } from './util/transformers';\nimport { isUndefined, isWindow } from './util/typeguards';\nimport { ViewportObserver } from './ViewportObserver';\n\ntype ElementBounds = {\n\tstart: number; //\t\tposition relative to viewport\n\tsize: number; // \t\touter visible size of element (excluding margins)\n\toffsetStart: number; // offset relative to top/left of element\n\toffsetEnd: number; // \toffset relative to bottom/right of element\n\ttrackSize: number; // \teffective track size including offsets\n};\ntype ContainerBounds = {\n\tclientSize: number; //\tinner visible area of scroll container (excluding scrollbars)\n\toffsetStart: number; // offset relative to top/left of container\n\toffsetEnd: number; // \toffset relative to bottom/right of container\n\ttrackSize: number; // \teffective track size including offsets\n\tscrollSize: number; //\ttotal size of content of container\n};\n\nexport interface ScrollMagicPlugin {\n\tonAdd?(this: ScrollMagic): void;\n\tonRemove?(this: ScrollMagic): void;\n\tonModify?(this: ScrollMagic, changesPublic: Options.Public): void;\n}\n\nexport class ScrollMagic {\n\tpublic readonly name = 'ScrollMagic';\n\n\tprivate readonly dispatcher = new EventDispatcher();\n\tprivate readonly container = new ContainerProxy(this);\n\tprivate readonly resizeObserver = new ResizeObserver(throttleRaf(this.onElementResize.bind(this)));\n\tprivate readonly viewportObserver = new ViewportObserver(this.onIntersectionChange.bind(this));\n\tprivate readonly executionQueue = new ExecutionQueue({\n\t\t// The order is important here! They will always be executed in exactly this order when scheduled for the same animation frame\n\t\telementBounds: this.updateElementBoundsCache.bind(this),\n\t\tcontainerBounds: this.updateContainerBoundsCache.bind(this),\n\t\tviewportObserver: this.updateViewportObserver.bind(this),\n\t\tprogress: this.updateProgress.bind(this),\n\t});\n\tprivate readonly update = this.executionQueue.commands; // not sure this is good style, but I kind of don't want to write this.executionQueue.commands every time...\n\tprivate readonly plugins = new Set<ScrollMagicPlugin>();\n\n\t// all below options should only ever be changed by a dedicated method\n\tprotected optionsPublic!: Required<Options.Public>; // set in modify in constructor\n\tprotected optionsPrivate!: Options.Private; // set in modify in constructor\n\tprotected elementBoundsCache: ElementBounds = {\n\t\t// see typedef for details\n\t\tstart: 0,\n\t\tsize: 0,\n\t\toffsetStart: 0,\n\t\toffsetEnd: 0,\n\t\ttrackSize: 0,\n\t};\n\tprotected containerBoundsCache: ContainerBounds = {\n\t\t// see typedef for details\n\t\tclientSize: 0,\n\t\toffsetStart: 0,\n\t\toffsetEnd: 0,\n\t\ttrackSize: 0,\n\t\tscrollSize: 0,\n\t};\n\tprotected currentProgress = 0;\n\tprotected intersecting?: boolean; // is the scene currently intersecting with the ViewportObserver?\n\n\t// TODO: correctly take into account container position, if not window\n\t// TODO: consider using MutationObserver to check if style of triggerElement or DOM element scrollParent are modified, which should trigger bounds recaluclations\n\t// TODO: fix if container size is 0\n\t// TODO: Maybe only include internal errors for development? process.env...\n\tconstructor(options: Options.Public = {}) {\n\t\tconst initOptions: Required<Options.Public> = {\n\t\t\t...ScrollMagic.defaultOptionsPublic,\n\t\t\t...options,\n\t\t};\n\t\tthis.modify(initOptions);\n\t}\n\n\tprotected getViewportMargin(): { top: string; left: string; right: string; bottom: string } {\n\t\tconst { vertical } = this.optionsPrivate;\n\t\tconst { start: startProp, end: endProp } = pickRelevantProps(vertical);\n\t\tconst { start: oppositeStartProp, end: oppositeEndProp } = pickRelevantProps(!vertical);\n\t\tconst { scrollSize: oppositeScrollSize, clientSize: oppositeClientSize } = pickRelevantValues(\n\t\t\t!vertical, // retrieving the opposites\n\t\t\tthis.container.rect // this is cached, so ok to get\n\t\t);\n\t\tconst {\n\t\t\tclientSize: containerSize,\n\t\t\toffsetStart: containerOffsetStart,\n\t\t\toffsetEnd: containerOffsetEnd,\n\t\t} = this.containerBoundsCache;\n\t\tconst { offsetStart, offsetEnd } = this.elementBoundsCache; // from cache\n\n\t\tconst marginStart = containerSize - containerOffsetStart + offsetStart;\n\t\tconst marginEnd = containerSize - containerOffsetEnd + offsetEnd;\n\t\t/**\n\t\t ** confusingly IntersectionObserver (and thus ViewportObserver) treat margins in the opposite direction (negative means towards the center)\n\t\t ** so we'll have to flip the signs here.\n\t\t ** Additionally we convert it to percentages and round, as this means they are less likely to change, meaning less refreshes for the observer\n\t\t ** (as the observer internally compares old values to new ones)\n\t\t ** This way it won't have to internally create new IntersectionObservers, just because the scrollparent's size changes.\n\t\t */\n\t\tconst noSize = containerSize <= 0;\n\t\tconst relMarginStart = noSize ? 0 : -roundToDecimals(marginStart / containerSize, 5);\n\t\tconst relMarginEnd = noSize ? 0 : -roundToDecimals(marginEnd / containerSize, 5);\n\n\t\t// adding available scrollspace in opposite direction, so element never moves out of trackable area, even when scrolling horizontally on a vertical scene\n\t\tconst noOppositeSize = oppositeClientSize <= 0;\n\t\tconst scrollableOpposite = noOppositeSize\n\t\t\t? 0\n\t\t\t: numberToPercString((oppositeScrollSize - oppositeClientSize) / oppositeClientSize);\n\t\treturn {\n\t\t\t// the start and end values are intentionally flipped here (start value defines end margin and vice versa)\n\t\t\t[endProp]: numberToPercString(relMarginStart),\n\t\t\t[startProp]: numberToPercString(relMarginEnd),\n\t\t\t[oppositeStartProp]: scrollableOpposite,\n\t\t\t[oppositeEndProp]: scrollableOpposite,\n\t\t} as Record<'top' | 'left' | 'bottom' | 'right', string>;\n\t}\n\n\tprotected getTrackSize(): number {\n\t\treturn this.elementBoundsCache.trackSize + this.containerBoundsCache.trackSize;\n\t}\n\n\t// !update functions MUST NOT call any other functions causing side effects, with the exceptions of modify and event triggers in progress\n\n\tprotected updateIntersectingState(nextIntersecting: boolean | undefined): void {\n\t\t// doesn't have to be a method, but I want to keep modifications obvious (only called from update... methods)\n\t\tthis.intersecting = nextIntersecting;\n\t}\n\n\tprotected updateElementBoundsCache(): void {\n\t\t// console.log(this.optionsPrivate.element.id, 'bounds', new Date().getMilliseconds());\n\t\t// this should be called cautiously, getBoundingClientRect costs...\n\t\t// check variable initialisation for property description\n\t\tconst { elementStart, elementEnd, element, vertical } = this.optionsPrivate;\n\t\tconst { start, size } = pickRelevantValues(vertical, element.getBoundingClientRect());\n\t\tconst offsetStart = elementStart(size);\n\t\tconst offsetEnd = elementEnd(size);\n\t\tthis.elementBoundsCache = {\n\t\t\tstart,\n\t\t\tsize,\n\t\t\toffsetStart,\n\t\t\toffsetEnd,\n\t\t\ttrackSize: size - offsetStart - offsetEnd,\n\t\t};\n\t}\n\n\tprotected updateContainerBoundsCache(): void {\n\t\t// console.log(this.optionsPrivate.element.id, 'container', new Date().getMilliseconds());\n\t\t// check variable initialisation for property description\n\t\tconst { triggerStart, triggerEnd, vertical } = this.optionsPrivate;\n\t\tconst { clientSize, scrollSize } = pickRelevantValues(vertical, this.container.rect);\n\t\tconst offsetStart = triggerStart(clientSize);\n\t\tconst offsetEnd = triggerEnd(clientSize);\n\t\tthis.containerBoundsCache = {\n\t\t\tclientSize,\n\t\t\tscrollSize,\n\t\t\toffsetStart,\n\t\t\toffsetEnd,\n\t\t\ttrackSize: -(clientSize - offsetStart - offsetEnd), // container track is inverted (start is usually below end)\n\t\t};\n\t}\n\n\tprotected updateProgress(): void {\n\t\t// console.log(this.optionsPrivate.element.id, 'progress', new Date().getMilliseconds());\n\t\tconst { offsetStart: elementOffset, start: elementPosition } = this.elementBoundsCache;\n\t\tconst { offsetStart: containerOffset } = this.containerBoundsCache;\n\t\tconst { start: containerPosition } = pickRelevantValues(this.optionsPrivate.vertical, this.container.rect);\n\n\t\tconst elementStart = elementPosition + elementOffset;\n\t\tconst containerStart = containerPosition + containerOffset;\n\t\tconst passed = containerStart - elementStart;\n\t\tconst total = this.getTrackSize();\n\n\t\tif (total < 0) {\n\t\t\treturn; // no overlap of track and scroll distance\n\t\t}\n\n\t\tconst previousProgress = this.currentProgress;\n\t\tconst nextProgress = Math.min(Math.max(passed / total, 0), 1); // when leaving, it will overshoot, this normalises to 0 / 1 (also when total is 0)\n\t\tconst deltaProgress = nextProgress - previousProgress;\n\n\t\tif (deltaProgress === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.currentProgress = nextProgress;\n\t\tconst forward = deltaProgress > 0;\n\n\t\tif (previousProgress === 0 || previousProgress === 1) {\n\t\t\tthis.triggerEvent(EventType.Enter, forward);\n\t\t}\n\t\tthis.triggerEvent(EventType.Progress, forward);\n\t\tif (nextProgress === 0 || nextProgress === 1) {\n\t\t\tthis.triggerEvent(EventType.Leave, forward);\n\t\t}\n\t}\n\n\tprotected updateViewportObserver(): void {\n\t\tconst { scrollParent } = this.optionsPrivate;\n\t\tconst observerOptions = {\n\t\t\tmargin: this.getViewportMargin(),\n\t\t\troot: isWindow(scrollParent) ? null : scrollParent,\n\t\t};\n\t\tthis.viewportObserver.modify(observerOptions);\n\t}\n\n\tprotected onOptionChanges(changedOptions: Options.Public): void {\n\t\tconst changes = Object.keys(changedOptions) as Array<keyof Options.Public>;\n\t\tif (changes.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst isChanged = changes.includes.bind(changes);\n\t\tconst elementStartChanged = isChanged('elementStart');\n\t\tconst elementEndChanged = isChanged('elementEnd');\n\t\tconst elementChanged = isChanged('element');\n\t\tconst scrollParentChanged = isChanged('scrollParent');\n\t\tconst triggerStartChanged = isChanged('triggerStart');\n\t\tconst triggerEndChanged = isChanged('triggerEnd');\n\t\tconst directionChanged = isChanged('vertical');\n\n\t\tif (elementStartChanged || elementEndChanged || elementChanged) {\n\t\t\tthis.update.elementBounds.schedule();\n\t\t\tif (elementChanged) {\n\t\t\t\tthis.updateIntersectingState(undefined);\n\t\t\t\tconst { element } = this.optionsPrivate;\n\t\t\t\tthis.viewportObserver.disconnect();\n\t\t\t\tthis.viewportObserver.observe(element);\n\t\t\t\tthis.resizeObserver.disconnect();\n\t\t\t\tthis.resizeObserver.observe(element);\n\t\t\t}\n\t\t}\n\t\tif (scrollParentChanged || triggerStartChanged || triggerEndChanged || directionChanged) {\n\t\t\tthis.update.viewportObserver.schedule();\n\t\t\tif (scrollParentChanged) {\n\t\t\t\tthis.update.containerBounds.schedule();\n\t\t\t\tthis.updateIntersectingState(undefined);\n\t\t\t\tthis.container.attach(this.optionsPrivate.scrollParent, this.onContainerUpdate.bind(this)); // container updates are already throttled\n\t\t\t}\n\t\t}\n\t\t// if any options changes we always have to refresh the progress\n\t\tthis.update.progress.schedule();\n\t}\n\n\tprotected onElementResize(): void {\n\t\t/**\n\t\t * * element resized\n\t\t * updateContainerBounds => \tnever\n\t\t * updateElementBounds =>\t\tschedule always (obviously),\t\texecute regardless.\n\t\t * updateViewportObserver => \tschedule always, \t\t\t\t\texecute if start or end offset changed in trigger bounds update above\n\t\t * updateProgress => \t\t\tschedule if currently intersecting,\texecute if start or end offset changed in trigger bounds update above\n\t\t */\n\t\tconst { update, elementBoundsCache } = this;\n\t\tconst { offsetStart: startPrevious, offsetEnd: endPrevious } = elementBoundsCache;\n\t\tconst isBoundsChanged = () =>\n\t\t\tstartPrevious !== elementBoundsCache.offsetStart || endPrevious !== elementBoundsCache.offsetEnd;\n\t\tupdate.elementBounds.schedule();\n\t\tupdate.viewportObserver.schedule(isBoundsChanged);\n\t\tif (this.intersecting) {\n\t\t\tupdate.progress.schedule(isBoundsChanged);\n\t\t}\n\t}\n\n\tprotected onContainerUpdate(e: ContainerEvent): void {\n\t\t/**\n\t\t * * container resized\n\t\t * updateContainerBounds => \tschedule always\t\t\t\t\t\t\texecute regardless\n\t\t * updateElementBounds => \t\tschedule if currently intersecting, \texecute regardless (resizes are caught in onElementResize but position might change due to container resize, which wouldn't be)\n\t\t * updateViewportObserver => \tschedule always (to get new margins),\texecute regardless.\n\t\t * updateProgress => \t\t\tschedule if currently intersecting, \texecute if position changed in triggerBounds update\n\t\t */\n\t\tconst { update } = this;\n\t\tif ('resize' === e.type) {\n\t\t\tthis.update.containerBounds.schedule();\n\t\t\tif (this.intersecting) {\n\t\t\t\tupdate.elementBounds.schedule();\n\t\t\t}\n\t\t\tupdate.viewportObserver.schedule();\n\t\t\tconst { start: startPrevious } = this.elementBoundsCache;\n\t\t\tconst isPositionChanged = () => startPrevious !== this.elementBoundsCache.start;\n\t\t\tupdate.progress.schedule(isPositionChanged);\n\t\t\treturn;\n\t\t}\n\t\t/**\n\t\t * * container scrolled\n\t\t * if relevant scrollDelta is 0, do nothing (scroll was in other direction)\n\t\t * updateContainerBounds => \tnever\n\t\t * updateElementBounds =>\t\tschedule if currently intersecting,\t\t\t\t\t\t\texecute regardless\n\t\t * updateViewportObserver => \tnever\n\t\t * updateProgress =>\t\t\tschedule if currently intersecting or potentially skipped, \texecute regardless (technically only execute if triggerBounds returned a new position, but that's implied, if there was a scoll move in the relevant direction)\n\t\t */\n\t\tconst { scrollDelta } = pickRelevantValues(this.optionsPrivate.vertical, e.scrollDelta);\n\t\tif (0 === scrollDelta) {\n\t\t\treturn; // scroll was in other direction\n\t\t}\n\t\t// in case the scroll position changes by more than the total track distance, the viewport observer might miss it.\n\t\t// this means running the progress update more than we have to, but in this case we have no choice.\n\t\tconst potentiallySkipped = Math.abs(scrollDelta) > this.getTrackSize();\n\n\t\tif (!this.intersecting && !potentiallySkipped) {\n\t\t\treturn;\n\t\t}\n\t\tupdate.elementBounds.schedule();\n\t\tupdate.progress.schedule();\n\t}\n\n\tprotected onIntersectionChange(intersecting: boolean, target: Element): void {\n\t\t// the check below should always be true, as we only ever observe one element, but you can never be too sure, I guess...\n\t\tif (target === this.optionsPrivate.element) {\n\t\t\t/**\n\t\t\t * * intersection state changed\n\t\t\t * updateContainerBounds => \tnever\n\t\t\t * updateElementBounds =>\t\tnever (would be caught by onElementResize or onContainerUpdate)\n\t\t\t * updateViewportObserver =>\tnever\n\t\t\t * updateProgress =>\t\t\tschedule regardless, execute regardless\n\t\t\t */\n\t\t\tthis.updateIntersectingState(intersecting);\n\t\t\tthis.update.progress.schedule();\n\t\t}\n\t}\n\n\tprotected triggerEvent(type: EventType, forward: boolean): void {\n\t\tthis.dispatcher.dispatchEvent(new ScrollMagicEvent(this, type, forward));\n\t}\n\n\tpublic modify(options: Options.Public): ScrollMagic {\n\t\tconst { sanitized, processed } = processOptions(options, this.optionsPrivate);\n\n\t\tconst changedOptions = isUndefined(this.optionsPublic) // not set on first run, so all changed\n\t\t\t? sanitized\n\t\t\t: pickDifferencesFlat(sanitized, this.optionsPublic);\n\n\t\tthis.optionsPublic = { ...this.optionsPublic, ...changedOptions };\n\t\tthis.optionsPrivate = processed;\n\n\t\tthis.onOptionChanges(changedOptions);\n\t\tthis.plugins.forEach(plugin => plugin.onModify?.call(this, changedOptions));\n\t\treturn this;\n\t}\n\n\tpublic addPlugin(plugin: ScrollMagicPlugin): ScrollMagic {\n\t\tthis.plugins.add(plugin);\n\t\tplugin.onAdd?.call(this);\n\t\treturn this;\n\t}\n\n\tpublic removePlugin(plugin: ScrollMagicPlugin): ScrollMagic {\n\t\tthis.plugins.delete(plugin);\n\t\tplugin.onRemove?.call(this);\n\t\treturn this;\n\t}\n\n\t// getter/setter public\n\tpublic set element(element: Required<Options.Public>['element']) {\n\t\tthis.modify({ element });\n\t}\n\tpublic get element(): Required<Options.Public>['element'] {\n\t\treturn this.optionsPublic.element;\n\t}\n\tpublic set scrollParent(scrollParent: Required<Options.Public>['scrollParent']) {\n\t\tthis.modify({ scrollParent });\n\t}\n\tpublic get scrollParent(): Required<Options.Public>['scrollParent'] {\n\t\treturn this.optionsPublic.scrollParent;\n\t}\n\tpublic set vertical(vertical: Required<Options.Public>['vertical']) {\n\t\tthis.modify({ vertical });\n\t}\n\tpublic get vertical(): Required<Options.Public>['vertical'] {\n\t\treturn this.optionsPublic.vertical;\n\t}\n\tpublic set triggerStart(triggerStart: Required<Options.Public>['triggerStart']) {\n\t\tthis.modify({ triggerStart });\n\t}\n\tpublic get triggerStart(): Required<Options.Public>['triggerStart'] {\n\t\treturn this.optionsPublic.triggerStart;\n\t}\n\tpublic set triggerEnd(triggerEnd: Required<Options.Public>['triggerEnd']) {\n\t\tthis.modify({ triggerEnd });\n\t}\n\tpublic get triggerEnd(): Required<Options.Public>['triggerEnd'] {\n\t\treturn this.optionsPublic.triggerEnd;\n\t}\n\tpublic set elementStart(elementStart: Required<Options.Public>['elementStart']) {\n\t\tthis.modify({ elementStart });\n\t}\n\tpublic get elementStart(): Required<Options.Public>['elementStart'] {\n\t\treturn this.optionsPublic.elementStart;\n\t}\n\tpublic set elementEnd(elementEnd: Required<Options.Public>['elementEnd']) {\n\t\tthis.modify({ elementEnd });\n\t}\n\tpublic get elementEnd(): Required<Options.Public>['elementEnd'] {\n\t\treturn this.optionsPublic.elementEnd;\n\t}\n\n\t// not an option -> getter only\n\tpublic get progress(): number {\n\t\treturn this.currentProgress;\n\t}\n\tpublic get scrollOffset(): { start: number; end: number } {\n\t\tthis.updateElementBoundsCache(); // need to get frash position\n\t\tconst { scrollParent, vertical } = this.optionsPrivate;\n\t\tconst { start: elementPosition, offsetStart, trackSize } = this.elementBoundsCache;\n\t\tconst {\n\t\t\tclientSize: containerSize,\n\t\t\toffsetStart: containerOffsetStart,\n\t\t\toffsetEnd: containerOffsetEnd,\n\t\t} = this.containerBoundsCache;\n\t\tconst { start: scrollOffset } = pickRelevantValues(vertical, getScrollPos(scrollParent));\n\n\t\tconst absolutePosition = elementPosition + scrollOffset;\n\t\tconst start = absolutePosition + offsetStart;\n\t\tconst end = start + trackSize;\n\t\treturn {\n\t\t\tstart: Math.floor(start - containerOffsetStart),\n\t\t\tend: Math.ceil(end - containerSize + containerOffsetEnd),\n\t\t};\n\t}\n\tpublic get computedOptions(): Options.PrivateComputed {\n\t\tconst { offsetStart: triggerStart, offsetEnd: triggerEnd } = this.containerBoundsCache;\n\t\tconst { offsetStart: elementStart, offsetEnd: elementEnd } = this.elementBoundsCache;\n\t\treturn {\n\t\t\t...this.optionsPrivate,\n\t\t\ttriggerStart,\n\t\t\ttriggerEnd,\n\t\t\telementStart,\n\t\t\telementEnd,\n\t\t};\n\t}\n\tpublic get pluginList(): Array<ScrollMagicPlugin> {\n\t\treturn [...this.plugins];\n\t}\n\n\t// event listener\n\tpublic on(type: `${EventType}`, cb: (e: ScrollMagicEvent) => void): ScrollMagic {\n\t\tthis.dispatcher.addEventListener(type, cb);\n\t\treturn this;\n\t}\n\tpublic off(type: `${EventType}`, cb: (e: ScrollMagicEvent) => void): ScrollMagic {\n\t\tthis.dispatcher.removeEventListener(type, cb);\n\t\treturn this;\n\t}\n\t// same as on, but returns a function to reverse the effect (remove the listener), so not chainable.\n\tpublic subscribe(type: `${EventType}`, cb: (e: ScrollMagicEvent) => void): () => void {\n\t\treturn this.dispatcher.addEventListener(type, cb);\n\t}\n\n\tpublic destroy(): void {\n\t\tthis.executionQueue.cancel();\n\t\tthis.resizeObserver.disconnect();\n\t\tthis.viewportObserver.disconnect();\n\t\tthis.container.detach();\n\t\tthis.plugins.forEach(this.removePlugin.bind(this));\n\t}\n\n\t// static options/methods\n\n\tprotected static defaultOptionsPublic = Options.defaults;\n\t// get or change default options\n\tpublic static defaultOptions(options: Options.Public = {}): Required<Options.Public> {\n\t\tthis.defaultOptionsPublic = {\n\t\t\t...this.defaultOptionsPublic,\n\t\t\t...sanitizeOptions(options),\n\t\t};\n\t\treturn this.defaultOptionsPublic;\n\t}\n\tpublic static readonly EventType = EventType;\n\tpublic static readonly EventLocation = EventLocation;\n\tpublic static readonly EventScrollDirection = ScrollDirection;\n}\n"],"names":["isNumber","val","isString","isUndefined","undefined","isNull","isWindow","Window","isHTMLElement","HTMLElement","isSVGElement","SVGElement","EventDispatcher","[object Object]","this","Map","type","cb","list","callbacks","get","set","push","removeEventListener","remaining","filter","registeredCallback","event","forEach","debounce","func","wait","timeoutId","debounced","args","clearTimeout","window","setTimeout","apply","cancel","getScrollContainerDimensions","element","elem","document","documentElement","clientWidth","scrollHeight","scrollWidth","clientHeight","innerHeight","scrollTop","container","pageYOffset","scrollLeft","pageXOffset","getScrollPos","left","top","registerEvent","target","listener","options","addEventListener","bind","throttleRaf","requestId","scheduled","requestAnimationFrame","cancelAnimationFrame","EventType","ContainerEvent","scrollDelta","deltaX","deltaY","Container","scrollParent","throttledScroll","updateScrollPos","debouncedResize","updateDimensions","throttledMove","updatePosition","cleanups","subscribeMove","subscribeScroll","subscribeResize","prevScrollPos","scrollPos","dispatcher","dispatchEvent","Scroll","dimensions","Resize","getBoundingClientRect","positionCache","onResize","observer","ResizeObserver","observe","unobserve","onScroll","onMove","listeners","cleanup","size","position","SM","ScrollMagicError","Error","message","super","ScrollMagicErrorInternal","failWith","failWithInternal","warn","first","console","ContainerProxy","scene","onUpdate","detach","cache","Set","scenes","add","unsubscribers","subscribe","delete","unsubscribe","destroy","rect","QueueItem","execute","onSchedule","condition","conditions","conditionsMet","some","ExecutionQueue","queueItems","commands","Object","entries","reduce","res","name","command","executeThrottled","values","item","resetConditions","defaults","vertical","triggerStart","triggerEnd","elementStart","elementEnd","inferredTriggers","default","scrollParentSize","fallback","verticalProps","start","end","clientSize","scrollSize","horizontalProps","pickRelevantProps","pickRelevantValues","obj","key","value","processProperties","processors","getErrorMessage","prop","reason","keys","result","processor","processedValue","e","numberToPercString","unitTupleToPixelConverter","unit","toPixelConverter","match","sign","digits","parseFloat","unitStringToPixelConverter","returnsNumber","toSvgOrHtmlElement","reference","selector","querySelector","selectorToSingleElement","body","contains","nullPassThrough","toNonNullable","recover","transformers","Document","sanitize","onUnknown","propertyName","sanitizeProperties","optionDefaults","process","newOptions","oldOptions","sanitized","normalized","processed","inferTrigger","firstElementChild","infer","elementSize","getElementSize","containerSize","check","EventLocation","ScrollDirection","ScrollMagicEvent","movingForward","location","Progress","Inside","Enter","Leave","Start","End","direction","Forward","Reverse","fromEntries","pickDifferencesFlat","part","full","roundToDecimals","decimals","toFixed","marginObjToString","right","bottom","join","ViewportObserver","callback","root","margin","isIntersecting","hitEnter","hitLeave","observedElements","prevState","observerEnter","newState","rootMargin","IntersectionObserver","observerCallback","disconnect","observerLeave","maxDimension","Math","max","marginEnter","marginLeave","createObserver","length","optionsChanged","rebuildObserver","has","clear","ScrollMagic","onElementResize","onIntersectionChange","elementBounds","updateElementBoundsCache","containerBounds","updateContainerBoundsCache","viewportObserver","updateViewportObserver","progress","updateProgress","executionQueue","offsetStart","offsetEnd","trackSize","initOptions","defaultOptionsPublic","modify","optionsPrivate","startProp","endProp","oppositeStartProp","oppositeEndProp","oppositeScrollSize","oppositeClientSize","containerOffsetStart","containerOffsetEnd","containerBoundsCache","elementBoundsCache","marginEnd","noSize","relMarginStart","relMarginEnd","scrollableOpposite","nextIntersecting","intersecting","elementOffset","elementPosition","containerOffset","containerPosition","passed","total","getTrackSize","previousProgress","currentProgress","nextProgress","min","deltaProgress","forward","triggerEvent","observerOptions","getViewportMargin","changedOptions","changes","isChanged","includes","elementStartChanged","elementEndChanged","elementChanged","scrollParentChanged","triggerStartChanged","triggerEndChanged","directionChanged","update","schedule","updateIntersectingState","resizeObserver","attach","onContainerUpdate","startPrevious","endPrevious","isBoundsChanged","isPositionChanged","potentiallySkipped","abs","processOptions","optionsPublic","onOptionChanges","plugins","plugin","onModify","call","onAdd","onRemove","scrollOffset","floor","ceil","computedOptions","pluginList","removePlugin","sanitizeOptions","Options.defaults"],"mappings":"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"}